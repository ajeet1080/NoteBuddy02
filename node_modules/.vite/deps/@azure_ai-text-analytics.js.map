{
  "version": 3,
  "sources": ["../../@azure/core-asynciterator-polyfill/src/index.ts", "../../@azure/core-auth/src/azureKeyCredential.ts", "../../@azure/core-auth/src/tokenCredential.ts", "../../@azure/ai-text-analytics/src/constants.ts", "../../@azure/core-client/src/base64.browser.ts", "../../@azure/core-client/src/interfaces.ts", "../../@azure/core-client/src/utils.ts", "../../@azure/core-client/src/serializer.ts", "../../@azure/core-client/src/operationHelpers.ts", "../../@azure/core-client/src/deserializationPolicy.ts", "../../@azure/core-client/src/interfaceHelpers.ts", "../../@azure/core-client/src/serializationPolicy.ts", "../../@azure/core-client/src/pipeline.ts", "../../@azure/core-client/src/httpClientCache.ts", "../../@azure/core-client/src/urlHelpers.ts", "../../@azure/core-client/src/log.ts", "../../@azure/core-client/src/serviceClient.ts", "../../@azure/ai-text-analytics/src/generated/models/mappers.ts", "../../@azure/ai-text-analytics/src/generated/models/parameters.ts", "../../@azure/ai-text-analytics/src/generated/generatedClientContext.ts", "../../@azure/ai-text-analytics/src/generated/generatedClient.ts", "../../@azure/ai-text-analytics/src/logger.ts", "../../@azure/ai-text-analytics/src/utils/url.browser.ts", "../../@azure/ai-text-analytics/src/util.ts", "../../@azure/ai-text-analytics/src/textAnalyticsResult.ts", "../../@azure/ai-text-analytics/src/detectLanguageResult.ts", "../../@azure/ai-text-analytics/src/detectLanguageResultArray.ts", "../../@azure/ai-text-analytics/src/recognizeCategorizedEntitiesResult.ts", "../../@azure/ai-text-analytics/src/recognizeCategorizedEntitiesResultArray.ts", "../../@azure/ai-text-analytics/src/analyzeSentimentResult.ts", "../../@azure/ai-text-analytics/src/analyzeSentimentResultArray.ts", "../../@azure/ai-text-analytics/src/extractKeyPhrasesResult.ts", "../../@azure/ai-text-analytics/src/extractKeyPhrasesResultArray.ts", "../../@azure/ai-text-analytics/src/recognizePiiEntitiesResult.ts", "../../@azure/ai-text-analytics/src/recognizePiiEntitiesResultArray.ts", "../../@azure/ai-text-analytics/src/recognizeLinkedEntitiesResult.ts", "../../@azure/ai-text-analytics/src/recognizeLinkedEntitiesResultArray.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/tracers/noop/noOpSpan.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/tracers/noop/noOpTracer.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/utils/global.browser.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/utils/cache.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/tracerProxy.ts", "../../@opentelemetry/api/src/platform/browser/globalThis.ts", "../../@opentelemetry/api/src/version.ts", "../../@opentelemetry/api/src/internal/semver.ts", "../../@opentelemetry/api/src/internal/global-utils.ts", "../../@opentelemetry/api/src/diag/ComponentLogger.ts", "../../@opentelemetry/api/src/diag/types.ts", "../../@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "../../@opentelemetry/api/src/api/diag.ts", "../../@opentelemetry/api/src/baggage/internal/baggage-impl.ts", "../../@opentelemetry/api/src/baggage/internal/symbol.ts", "../../@opentelemetry/api/src/baggage/utils.ts", "../../@opentelemetry/api/src/context/context.ts", "../../@opentelemetry/api/src/diag/consoleLogger.ts", "../../@opentelemetry/api/src/metrics/NoopMeter.ts", "../../@opentelemetry/api/src/metrics/Metric.ts", "../../@opentelemetry/api/src/propagation/TextMapPropagator.ts", "../../@opentelemetry/api/src/context/NoopContextManager.ts", "../../@opentelemetry/api/src/api/context.ts", "../../@opentelemetry/api/src/trace/trace_flags.ts", "../../@opentelemetry/api/src/trace/invalid-span-constants.ts", "../../@opentelemetry/api/src/trace/NonRecordingSpan.ts", "../../@opentelemetry/api/src/trace/context-utils.ts", "../../@opentelemetry/api/src/trace/spancontext-utils.ts", "../../@opentelemetry/api/src/trace/NoopTracer.ts", "../../@opentelemetry/api/src/trace/ProxyTracer.ts", "../../@opentelemetry/api/src/trace/NoopTracerProvider.ts", "../../@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "../../@opentelemetry/api/src/trace/SamplingResult.ts", "../../@opentelemetry/api/src/trace/span_kind.ts", "../../@opentelemetry/api/src/trace/status.ts", "../../@opentelemetry/api/src/trace/internal/tracestate-validators.ts", "../../@opentelemetry/api/src/trace/internal/tracestate-impl.ts", "../../@opentelemetry/api/src/context-api.ts", "../../@opentelemetry/api/src/diag-api.ts", "../../@opentelemetry/api/src/metrics/NoopMeterProvider.ts", "../../@opentelemetry/api/src/api/metrics.ts", "../../@opentelemetry/api/src/metrics-api.ts", "../../@opentelemetry/api/src/propagation/NoopTextMapPropagator.ts", "../../@opentelemetry/api/src/baggage/context-helpers.ts", "../../@opentelemetry/api/src/api/propagation.ts", "../../@opentelemetry/api/src/propagation-api.ts", "../../@opentelemetry/api/src/api/trace.ts", "../../@opentelemetry/api/src/trace-api.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/interfaces.ts", "../../@azure/ai-text-analytics/node_modules/@azure/core-tracing/src/createSpan.ts", "../../@azure/ai-text-analytics/src/tracing.ts", "../../@azure/ai-text-analytics/src/azureKeyCredentialPolicy.ts", "../../@azure/core-lro/src/logger.ts", "../../@azure/core-lro/src/legacy/poller.ts", "../../@azure/ai-text-analytics/src/lro/poller.ts", "../../@azure/ai-text-analytics/src/analyzeHealthcareEntitiesResult.ts", "../../@azure/ai-text-analytics/src/lro/health/operation.ts", "../../@azure/ai-text-analytics/src/lro/health/poller.ts", "../../@azure/ai-text-analytics/src/analyzeActionsResult.ts", "../../@azure/ai-text-analytics/src/lro/analyze/operation.ts", "../../@azure/ai-text-analytics/src/lro/analyze/poller.ts", "../../@azure/ai-text-analytics/src/textAnalyticsClient.ts"],
  "sourcesContent": ["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nif (typeof Symbol === undefined || !(Symbol as any).asyncIterator) {\n  (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Represents a credential defined by a static API key.\n */\nexport interface KeyCredential {\n  /**\n   * The value of the API key represented as a string\n   */\n  readonly key: string;\n}\n\n/**\n * A static-key-based credential that supports updating\n * the underlying key value.\n */\nexport class AzureKeyCredential implements KeyCredential {\n  private _key: string;\n\n  /**\n   * The value of the key to be used in authentication\n   */\n  public get key(): string {\n    return this._key;\n  }\n\n  /**\n   * Create an instance of an AzureKeyCredential for use\n   * with a service client.\n   *\n   * @param key - The initial value of the key to use in authentication\n   */\n  constructor(key: string) {\n    if (!key) {\n      throw new Error(\"key must be a non-empty string\");\n    }\n\n    this._key = key;\n  }\n\n  /**\n   * Change the value of the key.\n   *\n   * Updates will take effect upon the next request after\n   * updating the key value.\n   *\n   * @param newKey - The new key value to be used\n   */\n  public update(newKey: string): void {\n    this._key = newKey;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { TracingContext } from \"./tracing\";\n\n/**\n * Represents a credential capable of providing an authentication token.\n */\nexport interface TokenCredential {\n  /**\n   * Gets the token provided by this credential.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;\n}\n\n/**\n * Defines options for TokenCredential.getToken.\n */\nexport interface GetTokenOptions {\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Options used when creating and sending HTTP requests for this operation.\n   */\n  requestOptions?: {\n    /**\n     * The number of milliseconds a request can take before automatically being terminated.\n     */\n    timeout?: number;\n  };\n  /**\n   * Options used when tracing is enabled.\n   */\n  tracingOptions?: {\n    /**\n     * Tracing Context for the current request.\n     */\n    tracingContext?: TracingContext;\n  };\n  /**\n   * Claim details to perform the Continuous Access Evaluation authentication flow\n   */\n  claims?: string;\n  /**\n   * Indicates whether to enable the Continuous Access Evaluation authentication flow\n   */\n  enableCae?: boolean;\n  /**\n   * Allows specifying a tenantId. Useful to handle challenges that provide tenant Id hints.\n   */\n  tenantId?: string;\n}\n\n/**\n * Represents an access token with an expiration time.\n */\nexport interface AccessToken {\n  /**\n   * The access token returned by the authentication service.\n   */\n  token: string;\n\n  /**\n   * The access token's expiration timestamp in milliseconds, UNIX epoch time.\n   */\n  expiresOnTimestamp: number;\n}\n\n/**\n * Tests an object to determine whether it implements TokenCredential.\n *\n * @param credential - The assumed TokenCredential to be tested.\n */\nexport function isTokenCredential(credential: unknown): credential is TokenCredential {\n  // Check for an object with a 'getToken' function and possibly with\n  // a 'signRequest' function.  We do this check to make sure that\n  // a ServiceClientCredentials implementor (like TokenClientCredentials\n  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if\n  // it doesn't actually implement TokenCredential also.\n  const castCredential = credential as {\n    getToken: unknown;\n    signRequest: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.getToken === \"function\" &&\n    (castCredential.signRequest === undefined || castCredential.getToken.length > 0)\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * @internal\n */\nexport const SDK_VERSION: string = \"5.1.0\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\ndeclare global {\n  // stub these out for the browser\n  function btoa(input: string): string;\n  function atob(input: string): string;\n}\n\n/**\n * Encodes a string in base64 format.\n * @param value - the string to encode\n */\nexport function encodeString(value: string): string {\n  return btoa(value);\n}\n\n/**\n * Encodes a byte array in base64 format.\n * @param value - the Uint8Aray to encode\n */\nexport function encodeByteArray(value: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < value.length; i++) {\n    str += String.fromCharCode(value[i]);\n  }\n  return btoa(str);\n}\n\n/**\n * Decodes a base64 string into a byte array.\n * @param value - the base64 string to decode\n */\nexport function decodeString(value: string): Uint8Array {\n  const byteString = atob(value);\n  const arr = new Uint8Array(byteString.length);\n  for (let i = 0; i < byteString.length; i++) {\n    arr[i] = byteString.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Decodes a base64 string into a string.\n * @param value - the base64 string to decode\n */\nexport function decodeStringToString(value: string): string {\n  return atob(value);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  HttpClient,\n  HttpMethods,\n  PipelineOptions,\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"@azure/core-rest-pipeline\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * Default key used to access the XML attributes.\n */\nexport const XML_ATTRKEY = \"$\";\n/**\n * Default key used to access the XML value content.\n */\nexport const XML_CHARKEY = \"_\";\n/**\n * Options to govern behavior of xml parser and builder.\n */\nexport interface XmlOptions {\n  /**\n   * indicates the name of the root element in the resulting XML when building XML.\n   */\n  rootName?: string;\n  /**\n   * indicates whether the root element is to be included or not in the output when parsing XML.\n   */\n  includeRoot?: boolean;\n  /**\n   * key used to access the XML value content when parsing XML.\n   */\n  xmlCharKey?: string;\n}\n/**\n * Options to configure serialization/de-serialization behavior.\n */\nexport interface SerializerOptions {\n  /**\n   * Options to configure xml parser/builder behavior.\n   */\n  xml: XmlOptions;\n  /**\n   * Normally additional properties are included in the result object, even if there is no mapper for them.\n   * This flag disables this behavior when true. It is used when parsing headers to avoid polluting the result object.\n   */\n  ignoreUnknownProperties?: boolean;\n}\n\nexport type RequiredSerializerOptions = {\n  [K in keyof SerializerOptions]: Required<SerializerOptions[K]>;\n};\n\n/**\n * A type alias for future proofing.\n */\nexport type OperationRequest = PipelineRequest;\n\n/**\n * Metadata that is used to properly parse a response.\n */\nexport interface OperationRequestInfo {\n  /**\n   * Used to parse the response.\n   */\n  operationSpec?: OperationSpec;\n\n  /**\n   * Used to encode the request.\n   */\n  operationArguments?: OperationArguments;\n\n  /**\n   * A function that returns the proper OperationResponseMap for the given OperationSpec and\n   * PipelineResponse combination. If this is undefined, then a simple status code lookup will\n   * be used.\n   */\n  operationResponseGetter?: (\n    operationSpec: OperationSpec,\n    response: PipelineResponse,\n  ) => undefined | OperationResponseMap;\n\n  /**\n   * Whether or not the PipelineResponse should be deserialized. Defaults to true.\n   */\n  shouldDeserialize?: boolean | ((response: PipelineResponse) => boolean);\n}\n\n/**\n * The base options type for all operations.\n */\nexport interface OperationOptions {\n  /**\n   * The signal which can be used to abort requests.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Options used when creating and sending HTTP requests for this operation.\n   */\n  requestOptions?: OperationRequestOptions;\n  /**\n   * Options used when tracing is enabled.\n   */\n  tracingOptions?: OperationTracingOptions;\n  /**\n   * Options to override serialization/de-serialization behavior.\n   */\n  serializerOptions?: SerializerOptions;\n\n  /**\n   * A function to be called each time a response is received from the server\n   * while performing the requested operation.\n   * May be called multiple times.\n   */\n  onResponse?: RawResponseCallback;\n}\n\n/**\n * Options used when creating and sending HTTP requests for this operation.\n */\nexport interface OperationRequestOptions {\n  /**\n   * User defined custom request headers that\n   * will be applied before the request is sent.\n   */\n  customHeaders?: { [key: string]: string };\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   */\n  timeout?: number;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Callback which fires upon download progress.\n   */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Whether or not the HttpOperationResponse should be deserialized. If this is undefined, then the\n   * HttpOperationResponse should be deserialized.\n   */\n  shouldDeserialize?: boolean | ((response: PipelineResponse) => boolean);\n\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  allowInsecureConnection?: boolean;\n}\n\n/**\n * A collection of properties that apply to a single invocation of an operation.\n */\nexport interface OperationArguments {\n  /**\n   * The parameters that were passed to the operation method.\n   */\n  [parameterName: string]: unknown;\n\n  /**\n   * The optional arguments that are provided to an operation.\n   */\n  options?: OperationOptions;\n}\n\n/**\n * The format that will be used to join an array of values together for a query parameter value.\n */\nexport type QueryCollectionFormat = \"CSV\" | \"SSV\" | \"TSV\" | \"Pipes\" | \"Multi\";\n\n/**\n * Encodes how to reach a particular property on an object.\n */\nexport type ParameterPath = string | string[] | { [propertyName: string]: ParameterPath };\n\n/**\n * A common interface that all Operation parameter's extend.\n */\nexport interface OperationParameter {\n  /**\n   * The path to this parameter's value in OperationArguments or the object that contains paths for\n   * each property's value in OperationArguments.\n   */\n  parameterPath: ParameterPath;\n\n  /**\n   * The mapper that defines how to validate and serialize this parameter's value.\n   */\n  mapper: Mapper;\n}\n\n/**\n * A parameter for an operation that will be substituted into the operation's request URL.\n */\nexport interface OperationURLParameter extends OperationParameter {\n  /**\n   * Whether or not to skip encoding the URL parameter's value before adding it to the URL.\n   */\n  skipEncoding?: boolean;\n}\n\n/**\n * A parameter for an operation that will be added as a query parameter to the operation's HTTP\n * request.\n */\nexport interface OperationQueryParameter extends OperationParameter {\n  /**\n   * Whether or not to skip encoding the query parameter's value before adding it to the URL.\n   */\n  skipEncoding?: boolean;\n\n  /**\n   * If this query parameter's value is a collection, what type of format should the value be\n   * converted to.\n   */\n  collectionFormat?: QueryCollectionFormat;\n}\n\n/**\n * An OperationResponse that can be returned from an operation request for a single status code.\n */\nexport interface OperationResponseMap {\n  /**\n   * The mapper that will be used to deserialize the response headers.\n   */\n  headersMapper?: Mapper;\n\n  /**\n   * The mapper that will be used to deserialize the response body.\n   */\n  bodyMapper?: Mapper;\n\n  /**\n   * Indicates if this is an error response\n   */\n  isError?: boolean;\n}\n\n/**\n * A specification that defines an operation.\n */\nexport interface OperationSpec {\n  /**\n   * The serializer to use in this operation.\n   */\n  readonly serializer: Serializer;\n\n  /**\n   * The HTTP method that should be used by requests for this operation.\n   */\n  readonly httpMethod: HttpMethods;\n\n  /**\n   * The URL that was provided in the service's specification. This will still have all of the URL\n   * template variables in it. If this is not provided when the OperationSpec is created, then it\n   * will be populated by a \"baseUri\" property on the ServiceClient.\n   */\n  readonly baseUrl?: string;\n\n  /**\n   * The fixed path for this operation's URL. This will still have all of the URL template variables\n   * in it.\n   */\n  readonly path?: string;\n\n  /**\n   * The content type of the request body. This value will be used as the \"Content-Type\" header if\n   * it is provided.\n   */\n  readonly contentType?: string;\n\n  /**\n   * The media type of the request body.\n   * This value can be used to aide in serialization if it is provided.\n   */\n  readonly mediaType?:\n    | \"json\"\n    | \"xml\"\n    | \"form\"\n    | \"binary\"\n    | \"multipart\"\n    | \"text\"\n    | \"unknown\"\n    | string;\n  /**\n   * The parameter that will be used to construct the HTTP request's body.\n   */\n  readonly requestBody?: OperationParameter;\n\n  /**\n   * Whether or not this operation uses XML request and response bodies.\n   */\n  readonly isXML?: boolean;\n\n  /**\n   * The parameters to the operation method that will be substituted into the constructed URL.\n   */\n  readonly urlParameters?: ReadonlyArray<OperationURLParameter>;\n\n  /**\n   * The parameters to the operation method that will be added to the constructed URL's query.\n   */\n  readonly queryParameters?: ReadonlyArray<OperationQueryParameter>;\n\n  /**\n   * The parameters to the operation method that will be converted to headers on the operation's\n   * HTTP request.\n   */\n  readonly headerParameters?: ReadonlyArray<OperationParameter>;\n\n  /**\n   * The parameters to the operation method that will be used to create a formdata body for the\n   * operation's HTTP request.\n   */\n  readonly formDataParameters?: ReadonlyArray<OperationParameter>;\n\n  /**\n   * The different types of responses that this operation can return based on what status code is\n   * returned.\n   */\n  readonly responses: { [responseCode: string]: OperationResponseMap };\n}\n\n/**\n * Wrapper object for http request and response. Deserialized object is stored in\n * the `parsedBody` property when the response body is received in JSON or XML.\n */\nexport interface FullOperationResponse extends PipelineResponse {\n  /**\n   * The parsed HTTP response headers.\n   */\n  parsedHeaders?: { [key: string]: unknown };\n\n  /**\n   * The response body as parsed JSON or XML.\n   */\n  parsedBody?: any;\n\n  /**\n   * The request that generated the response.\n   */\n  request: OperationRequest;\n}\n\n/**\n * A function to be called each time a response is received from the server\n * while performing the requested operation.\n * May be called multiple times.\n */\nexport type RawResponseCallback = (\n  rawResponse: FullOperationResponse,\n  flatResponse: unknown,\n  error?: unknown,\n) => void;\n\n/**\n * Used to map raw response objects to final shapes.\n * Helps packing and unpacking Dates and other encoded types that are not intrinsic to JSON.\n * Also allows pulling values from headers, as well as inserting default values and constants.\n */\nexport interface Serializer {\n  /**\n   * The provided model mapper.\n   */\n  readonly modelMappers: { [key: string]: any };\n  /**\n   * Whether the contents are XML or not.\n   */\n  readonly isXML: boolean;\n\n  /**\n   * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.\n   * @param mapper - The definition of data models.\n   * @param value - The value.\n   * @param objectName - Name of the object. Used in the error messages.\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void;\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param object - A valid Javascript object to be serialized.\n   * @param objectName - Name of the serialized object.\n   * @param options - additional options to deserialization.\n   * @returns A valid serialized Javascript object.\n   */\n  serialize(mapper: Mapper, object: any, objectName?: string, options?: SerializerOptions): any;\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param responseBody - A valid Javascript entity to be deserialized.\n   * @param objectName - Name of the deserialized object.\n   * @param options - Controls behavior of XML parser and builder.\n   * @returns A valid deserialized Javascript object.\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: any,\n    objectName: string,\n    options?: SerializerOptions,\n  ): any;\n}\n\n/**\n * Description of various value constraints such as integer ranges and string regex.\n */\nexport interface MapperConstraints {\n  /**\n   * The value should be less than or equal to the `InclusiveMaximum` value.\n   */\n  InclusiveMaximum?: number;\n  /**\n   * The value should be less than the `ExclusiveMaximum` value.\n   */\n  ExclusiveMaximum?: number;\n  /**\n   * The value should be greater than or equal to the `InclusiveMinimum` value.\n   */\n  InclusiveMinimum?: number;\n  /**\n   * The value should be greater than the `InclusiveMinimum` value.\n   */\n  ExclusiveMinimum?: number;\n  /**\n   * The length should be smaller than the `MaxLength`.\n   */\n  MaxLength?: number;\n  /**\n   * The length should be bigger than the `MinLength`.\n   */\n  MinLength?: number;\n  /**\n   * The value must match the pattern.\n   */\n  Pattern?: RegExp;\n  /**\n   * The value must contain fewer items than the MaxItems value.\n   */\n  MaxItems?: number;\n  /**\n   * The value must contain more items than the `MinItems` value.\n   */\n  MinItems?: number;\n  /**\n   * The value must contain only unique items.\n   */\n  UniqueItems?: true;\n  /**\n   * The value should be exactly divisible by the `MultipleOf` value.\n   */\n  MultipleOf?: number;\n}\n\n/**\n * Type of the mapper. Includes known mappers.\n */\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\n/**\n * The type of a simple mapper.\n */\nexport interface SimpleMapperType {\n  /**\n   * Name of the type of the property.\n   */\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\n/**\n * Helps build a mapper that describes how to map a set of properties of an object based on other mappers.\n *\n * Only one of the following properties should be present: `className`, `modelProperties` and `additionalProperties`.\n */\nexport interface CompositeMapperType {\n  /**\n   * Name of the composite mapper type.\n   */\n  name: \"Composite\";\n\n  /**\n   * Use `className` to reference another type definition.\n   */\n  className?: string;\n\n  /**\n   * Use `modelProperties` when the reference to the other type has been resolved.\n   */\n  modelProperties?: { [propertyName: string]: Mapper };\n\n  /**\n   * Used when a model has `additionalProperties: true`. Allows the generic processing of unnamed model properties on the response object.\n   */\n  additionalProperties?: Mapper;\n\n  /**\n   * The name of the top-most parent scheme, the one that has no parents.\n   */\n  uberParent?: string;\n\n  /**\n   * A polymorphic discriminator.\n   */\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\n/**\n * Helps build a mapper that describes how to parse a sequence of mapped values.\n */\nexport interface SequenceMapperType {\n  /**\n   * Name of the sequence type mapper.\n   */\n  name: \"Sequence\";\n  /**\n   * The mapper to use to map each one of the properties of the sequence.\n   */\n  element: Mapper;\n}\n\n/**\n * Helps build a mapper that describes how to parse a dictionary of mapped values.\n */\nexport interface DictionaryMapperType {\n  /**\n   * Name of the sequence type mapper.\n   */\n  name: \"Dictionary\";\n  /**\n   * The mapper to use to map the value of each property in the dictionary.\n   */\n  value: Mapper;\n}\n\n/**\n * Helps build a mapper that describes how to parse an enum value.\n */\nexport interface EnumMapperType {\n  /**\n   * Name of the enum type mapper.\n   */\n  name: \"Enum\";\n  /**\n   * Values allowed by this mapper.\n   */\n  allowedValues: any[];\n}\n\n/**\n * The base definition of a mapper. Can be used for XML and plain JavaScript objects.\n */\nexport interface BaseMapper {\n  /**\n   * Name for the xml element\n   */\n  xmlName?: string;\n  /**\n   * Xml element namespace\n   */\n  xmlNamespace?: string;\n  /**\n   * Xml element namespace prefix\n   */\n  xmlNamespacePrefix?: string;\n  /**\n   * Determines if the current property should be serialized as an attribute of the parent xml element\n   */\n  xmlIsAttribute?: boolean;\n  /**\n   * Determines if the current property should be serialized as the inner content of the xml element\n   */\n  xmlIsMsText?: boolean;\n  /**\n   * Name for the xml elements when serializing an array\n   */\n  xmlElementName?: string;\n  /**\n   * Whether or not the current property should have a wrapping XML element\n   */\n  xmlIsWrapped?: boolean;\n  /**\n   * Whether or not the current property is readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Whether or not the current property is a constant\n   */\n  isConstant?: boolean;\n  /**\n   * Whether or not the current property is required\n   */\n  required?: boolean;\n  /**\n   * Whether or not the current property allows mull as a value\n   */\n  nullable?: boolean;\n  /**\n   * The name to use when serializing\n   */\n  serializedName?: string;\n  /**\n   * Type of the mapper\n   */\n  type: MapperType;\n  /**\n   * Default value when one is not explicitly provided\n   */\n  defaultValue?: any;\n  /**\n   * Constraints to test the current value against\n   */\n  constraints?: MapperConstraints;\n}\n\n/**\n * Mappers are definitions of the data models used in the library.\n * These data models are part of the Operation or Client definitions in the responses or parameters.\n */\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\n/**\n * Used to disambiguate discriminated type unions.\n * For example, if response can have many shapes but also includes a 'kind' field (or similar),\n * that field can be used to determine how to deserialize the response to the correct type.\n */\nexport interface PolymorphicDiscriminator {\n  /**\n   * Name of the discriminant property in the original JSON payload, e.g. `@odata.kind`.\n   */\n  serializedName: string;\n  /**\n   * Name to use on the resulting object instead of the original property name.\n   * Useful since the JSON property could be difficult to work with.\n   * For example: For a field received as `@odata.kind`, the final object could instead include a property simply named `kind`.\n   */\n  clientName: string;\n  /**\n   * It may contain any other property.\n   */\n  [key: string]: string;\n}\n\n/**\n * A mapper composed of other mappers.\n */\nexport interface CompositeMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `CompositeMapper`.\n   */\n  type: CompositeMapperType;\n}\n\n/**\n * A mapper describing arrays.\n */\nexport interface SequenceMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `SequenceMapper`.\n   */\n  type: SequenceMapperType;\n}\n\n/**\n * A mapper describing plain JavaScript objects used as key/value pairs.\n */\nexport interface DictionaryMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `DictionaryMapper`.\n   */\n  type: DictionaryMapperType;\n  /**\n   * Optionally, a prefix to add to the header collection.\n   */\n  headerCollectionPrefix?: string;\n}\n\n/**\n * A mapper describing an enum value.\n */\nexport interface EnumMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `EnumMapper`.\n   */\n  type: EnumMapperType;\n}\n\nexport interface UrlParameterValue {\n  value: string;\n  skipUrlEncoding: boolean;\n}\n\n/**\n * Configuration for creating a new Tracing Span\n */\nexport interface SpanConfig {\n  /**\n   * Package name prefix\n   */\n  packagePrefix: string;\n  /**\n   * Service namespace\n   */\n  namespace: string;\n}\n\n/**\n * Used to configure additional policies added to the pipeline at construction.\n */\nexport interface AdditionalPolicyConfig {\n  /**\n   * A policy to be added.\n   */\n  policy: PipelinePolicy;\n  /**\n   * Determines if this policy be applied before or after retry logic.\n   * Only use `perRetry` if you need to modify the request again\n   * each time the operation is retried due to retryable service\n   * issues.\n   */\n  position: \"perCall\" | \"perRetry\";\n}\n\n/**\n * The common set of options that high level clients are expected to expose.\n */\nexport interface CommonClientOptions extends PipelineOptions {\n  /**\n   * The HttpClient that will be used to send HTTP requests.\n   */\n  httpClient?: HttpClient;\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  allowInsecureConnection?: boolean;\n  /**\n   * Additional policies to include in the HTTP pipeline.\n   */\n  additionalPolicies?: AdditionalPolicyConfig[];\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CompositeMapper, FullOperationResponse, OperationResponseMap } from \"./interfaces\";\n\n/**\n * The union of all possible types for a primitive response body.\n * @internal\n */\nexport type BodyPrimitive = number | string | boolean | Date | Uint8Array | undefined | null;\n\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value: unknown, mapperTypeName?: string): value is BodyPrimitive {\n  return (\n    mapperTypeName !== \"Composite\" &&\n    mapperTypeName !== \"Dictionary\" &&\n    (typeof value === \"string\" ||\n      typeof value === \"number\" ||\n      typeof value === \"boolean\" ||\n      mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !==\n        null ||\n      value === undefined ||\n      value === null)\n  );\n}\n\nconst validateISODuration =\n  /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value: string): boolean {\n  return validateISODuration.test(value);\n}\n\nconst validUuidRegex =\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid: string): boolean {\n  return validUuidRegex.test(uuid);\n}\n\n/**\n * Representation of parsed response headers and body coupled with information\n * about how to map them:\n * - whether the response body should be wrapped (typically if its type is primitive).\n * - whether the response is nullable so it can be null if the combination of\n *   the headers and the body is empty.\n */\ninterface ResponseObjectWithMetadata {\n  /** whether the mapper allows nullable body */\n  hasNullableType: boolean;\n  /** whether the response's body should be wrapped */\n  shouldWrapBody: boolean;\n  /** parsed headers of the response */\n  headers:\n    | {\n        [key: string]: unknown;\n      }\n    | undefined;\n  /** parsed body of the response */\n  body: any;\n}\n\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(\n  responseObject: ResponseObjectWithMetadata,\n): unknown | null {\n  const combinedHeadersAndBody = {\n    ...responseObject.headers,\n    ...responseObject.body,\n  };\n  if (\n    responseObject.hasNullableType &&\n    Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0\n  ) {\n    return responseObject.shouldWrapBody ? { body: null } : null;\n  } else {\n    return responseObject.shouldWrapBody\n      ? {\n          ...responseObject.headers,\n          body: responseObject.body,\n        }\n      : combinedHeadersAndBody;\n  }\n}\n\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(\n  fullResponse: FullOperationResponse,\n  responseSpec: OperationResponseMap | undefined,\n): unknown {\n  const parsedHeaders = fullResponse.parsedHeaders;\n\n  // head methods never have a body, but we return a boolean set to body property\n  // to indicate presence/absence of the resource\n  if (fullResponse.request.method === \"HEAD\") {\n    return {\n      ...parsedHeaders,\n      body: fullResponse.parsedBody,\n    };\n  }\n  const bodyMapper = responseSpec && responseSpec.bodyMapper;\n  const isNullable = Boolean(bodyMapper?.nullable);\n  const expectedBodyTypeName = bodyMapper?.type.name;\n\n  /** If the body is asked for, we look at the expected body type to handle it */\n  if (expectedBodyTypeName === \"Stream\") {\n    return {\n      ...parsedHeaders,\n      blobBody: fullResponse.blobBody,\n      readableStreamBody: fullResponse.readableStreamBody,\n    };\n  }\n\n  const modelProperties =\n    (expectedBodyTypeName === \"Composite\" &&\n      (bodyMapper as CompositeMapper).type.modelProperties) ||\n    {};\n  const isPageableResponse = Object.keys(modelProperties).some(\n    (k) => modelProperties[k].serializedName === \"\",\n  );\n  if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n    const arrayResponse: { [key: string]: unknown } =\n      fullResponse.parsedBody ?? ([] as unknown as { [key: string]: unknown });\n\n    for (const key of Object.keys(modelProperties)) {\n      if (modelProperties[key].serializedName) {\n        arrayResponse[key] = fullResponse.parsedBody?.[key];\n      }\n    }\n\n    if (parsedHeaders) {\n      for (const key of Object.keys(parsedHeaders)) {\n        arrayResponse[key] = parsedHeaders[key];\n      }\n    }\n    return isNullable &&\n      !fullResponse.parsedBody &&\n      !parsedHeaders &&\n      Object.getOwnPropertyNames(modelProperties).length === 0\n      ? null\n      : arrayResponse;\n  }\n\n  return handleNullableResponseAndWrappableBody({\n    body: fullResponse.parsedBody,\n    headers: parsedHeaders,\n    hasNullableType: isNullable,\n    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n  });\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as base64 from \"./base64\";\nimport {\n  BaseMapper,\n  CompositeMapper,\n  DictionaryMapper,\n  EnumMapper,\n  Mapper,\n  MapperConstraints,\n  PolymorphicDiscriminator,\n  RequiredSerializerOptions,\n  SequenceMapper,\n  Serializer,\n  SerializerOptions,\n  XML_ATTRKEY,\n  XML_CHARKEY,\n} from \"./interfaces\";\nimport { isDuration, isValidUuid } from \"./utils\";\n\nclass SerializerImpl implements Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML: boolean = false,\n  ) {}\n\n  /**\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void {\n    const failValidation = (\n      constraintName: keyof MapperConstraints,\n      constraintValue: any,\n    ): never => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`,\n      );\n    };\n    if (mapper.constraints && value !== undefined && value !== null) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems,\n      } = mapper.constraints;\n      if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems !== undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength !== undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems !== undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength !== undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        value.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param object - A valid Javascript object to be serialized\n   *\n   * @param objectName - Name of the serialized object\n   *\n   * @param options - additional options to serialization\n   *\n   * @returns A valid serialized Javascript object\n   */\n  serialize(\n    mapper: Mapper,\n    object: any,\n    objectName?: string,\n    options: SerializerOptions = { xml: {} },\n  ): any {\n    const updatedOptions: RequiredSerializerOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY,\n      },\n    };\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && (object === undefined || object === null)) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object === undefined || object === null) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions,\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions,\n        );\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(\n          this,\n          mapper as CompositeMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions,\n        );\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object\n   *\n   * @param responseBody - A valid Javascript entity to be deserialized\n   *\n   * @param objectName - Name of the deserialized object\n   *\n   * @param options - Controls behavior of XML parser and builder.\n   *\n   * @returns A valid deserialized Javascript object\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: any,\n    objectName: string,\n    options: SerializerOptions = { xml: {} },\n  ): any {\n    const updatedOptions: RequiredSerializerOptions = {\n      xml: {\n        rootName: options.xml.rootName ?? \"\",\n        includeRoot: options.xml.includeRoot ?? false,\n        xmlCharKey: options.xml.xmlCharKey ?? XML_CHARKEY,\n      },\n      ignoreUnknownProperties: options.ignoreUnknownProperties ?? false,\n    };\n    if (responseBody === undefined || responseBody === null) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(\n        this,\n        mapper as CompositeMapper,\n        responseBody,\n        objectName,\n        updatedOptions,\n      );\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xml.xmlCharKey;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n          responseBody = responseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          responseBody,\n          objectName,\n          updatedOptions,\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName,\n          updatedOptions,\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(\n  modelMappers: { [key: string]: any } = {},\n  isXML: boolean = false,\n): Serializer {\n  return new SerializerImpl(modelMappers, isXML);\n}\n\nfunction trimEnd(str: string, ch: string): string {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: Uint8Array): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`,\n        );\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        typeof value.pipe !== \"function\" && // NodeJS.ReadableStream\n        typeof value.tee !== \"function\" && // browser ReadableStream\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        // File objects count as a type of Blob, so we want to use instanceof explicitly\n        !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) &&\n        objectType !== \"function\"\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`,\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`,\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues,\n      )}.`,\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: any): any {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: any): any {\n  if (value !== undefined && value !== null) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string): any {\n  if (value !== undefined && value !== null) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`,\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`,\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  let elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`,\n    );\n  }\n  // Quirk: Composite mappers referenced by `element` might\n  // not have *all* properties declared (like uberParent),\n  // so let's try to look up the full definition by name.\n  if (elementType.type.name === \"Composite\" && elementType.type.className) {\n    elementType = serializer.modelMappers[elementType.type.className] ?? elementType;\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix\n        ? `xmlns:${elementType.xmlNamespacePrefix}`\n        : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = { ...serializedValue };\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xml.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`,\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n    return result;\n  }\n\n  return tempDictionary;\n}\n\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string,\n): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string,\n): CompositeMapper | undefined {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(\n      `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n        mapper,\n        undefined,\n        2,\n      )}\".`,\n    );\n  }\n\n  return serializer.modelMappers[className];\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string,\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(modelMapper)}\" of type \"${\n            mapper.type.className\n          }\" for object \"${objectName}\".`,\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object !== undefined && object !== null) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (\n            (childObject === undefined || childObject === null) &&\n            ((object[key] !== undefined && object[key] !== null) ||\n              propertyMapper.defaultValue !== undefined)\n          ) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject !== undefined && parentObject !== null) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix\n            ? `xmlns:${mapper.xmlNamespacePrefix}`\n            : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace,\n          };\n        }\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          (toSerialize === undefined || toSerialize === null)\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName,\n          options,\n        );\n        if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]',\n            options,\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction getXmlObjectValue(\n  propertyMapper: Mapper,\n  serializedValue: any,\n  isXml: boolean,\n  options: RequiredSerializerOptions,\n): any {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix\n    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n    : \"xmlns\";\n  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result: any = { ...serializedValue };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result: any = {};\n  result[options.xml.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName: string, options: RequiredSerializerOptions): boolean {\n  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions,\n): any {\n  const xmlCharKey = options.xml.xmlCharKey ?? XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName,\n            options,\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody[XML_ATTRKEY][xmlName!],\n          propertyObjectName,\n          options,\n        );\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName!];\n          const elementList = wrapped?.[xmlElementName!] ?? [];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            elementList,\n            propertyObjectName,\n            options,\n          );\n          handledPropertyNames.push(xmlName!);\n        } else {\n          const property = responseBody[propertyName!];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            property,\n            propertyObjectName,\n            options,\n          );\n          handledPropertyNames.push(propertyName!);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      let steps = 0;\n      for (const item of paths) {\n        if (!res) break;\n        steps++;\n        res = res[item];\n      }\n      // only accept null when reaching the last position of object otherwise it would be undefined\n      if (res === null && steps < paths.length) {\n        res = undefined;\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        (propertyInstance === undefined || propertyInstance === null)\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options,\n        );\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options,\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string): boolean => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]',\n          options,\n        );\n      }\n    }\n  } else if (responseBody && !options.ignoreUnknownProperties) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key, options)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions,\n): any {\n  /* jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`,\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string,\n  options: RequiredSerializerOptions,\n): any {\n  let element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`,\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (element.type.name === \"Composite\" && element.type.className) {\n      element = serializer.modelMappers[element.type.className] ?? element;\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(\n        element,\n        responseBody[i],\n        `${objectName}[${i}]`,\n        options,\n      );\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getIndexDiscriminator(\n  discriminators: Record<string, CompositeMapper>,\n  discriminatorValue: string,\n  typeName: string,\n): CompositeMapper | undefined {\n  const typeNamesToCheck = [typeName];\n  while (typeNamesToCheck.length) {\n    const currentName = typeNamesToCheck.shift();\n    const indexDiscriminator =\n      discriminatorValue === currentName\n        ? discriminatorValue\n        : currentName + \".\" + discriminatorValue;\n    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n      return discriminators[indexDiscriminator];\n    } else {\n      for (const [name, mapper] of Object.entries(discriminators)) {\n        if (\n          name.startsWith(currentName + \".\") &&\n          mapper.type.uberParent === currentName &&\n          mapper.type.className\n        ) {\n          typeNamesToCheck.push(mapper.type.className);\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\",\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName) {\n      // The serializedName might have \\\\, which we just want to ignore\n      if (polymorphicPropertyName === \"serializedName\") {\n        discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n      }\n      const discriminatorValue = object[discriminatorName];\n      const typeName = mapper.type.uberParent ?? mapper.type.className;\n\n      if (typeof discriminatorValue === \"string\" && typeName) {\n        const polymorphicMapper = getIndexDiscriminator(\n          serializer.modelMappers.discriminators,\n          discriminatorValue,\n          typeName,\n        );\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(\n  serializer: Serializer,\n  typeName?: string,\n): PolymorphicDiscriminator | undefined {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n  Base64Url: \"Base64Url\",\n  Boolean: \"Boolean\",\n  ByteArray: \"ByteArray\",\n  Composite: \"Composite\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTimeRfc1123: \"DateTimeRfc1123\",\n  Dictionary: \"Dictionary\",\n  Enum: \"Enum\",\n  Number: \"Number\",\n  Object: \"Object\",\n  Sequence: \"Sequence\",\n  String: \"String\",\n  Stream: \"Stream\",\n  TimeSpan: \"TimeSpan\",\n  UnixTime: \"UnixTime\",\n} as const;\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CompositeMapper,\n  Mapper,\n  OperationArguments,\n  OperationParameter,\n  OperationRequest,\n  OperationRequestInfo,\n  ParameterPath,\n} from \"./interfaces\";\n\n/**\n * @internal\n * Retrieves the value to use for a given operation argument\n * @param operationArguments - The arguments passed from the generated client\n * @param parameter - The parameter description\n * @param fallbackObject - If something isn't found in the arguments bag, look here.\n *  Generally used to look at the service client properties.\n */\nexport function getOperationArgumentValueFromParameter(\n  operationArguments: OperationArguments,\n  parameter: OperationParameter,\n  fallbackObject?: { [parameterName: string]: any },\n): any {\n  let parameterPath = parameter.parameterPath;\n  const parameterMapper = parameter.mapper;\n  let value: any;\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n\n        if (!propertySearchResult.propertyFound && fallbackObject) {\n          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);\n        }\n\n        let useDefaultValue = false;\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue =\n            parameterMapper.required ||\n            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n        }\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      }\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (const propertyName in parameterPath) {\n      const propertyMapper: Mapper = (parameterMapper as CompositeMapper).type.modelProperties![\n        propertyName\n      ];\n      const propertyPath: ParameterPath = parameterPath[propertyName];\n      const propertyValue: any = getOperationArgumentValueFromParameter(\n        operationArguments,\n        {\n          parameterPath: propertyPath,\n          mapper: propertyMapper,\n        },\n        fallbackObject,\n      );\n      if (propertyValue !== undefined) {\n        if (!value) {\n          value = {};\n        }\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n  return value;\n}\n\ninterface PropertySearchResult {\n  propertyValue?: any;\n  propertyFound: boolean;\n}\n\nfunction getPropertyFromParameterPath(\n  parent: { [parameterName: string]: any },\n  parameterPath: string[],\n): PropertySearchResult {\n  const result: PropertySearchResult = { propertyFound: false };\n  let i = 0;\n  for (; i < parameterPath.length; ++i) {\n    const parameterPathPart: string = parameterPath[i];\n    // Make sure to check inherited properties too, so don't use hasOwnProperty().\n    if (parent && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n  return result;\n}\n\nconst operationRequestMap = new WeakMap<OperationRequest, OperationRequestInfo>();\nconst originalRequestSymbol = Symbol.for(\"@azure/core-client original request\");\n\nfunction hasOriginalRequest(\n  request: OperationRequest,\n): request is OperationRequest & { [originalRequestSymbol]: OperationRequest } {\n  return originalRequestSymbol in request;\n}\n\nexport function getOperationRequestInfo(request: OperationRequest): OperationRequestInfo {\n  if (hasOriginalRequest(request)) {\n    return getOperationRequestInfo(request[originalRequestSymbol]);\n  }\n  let info = operationRequestMap.get(request);\n\n  if (!info) {\n    info = {};\n    operationRequestMap.set(request, info);\n  }\n  return info;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  FullOperationResponse,\n  OperationRequest,\n  OperationResponseMap,\n  OperationSpec,\n  RequiredSerializerOptions,\n  SerializerOptions,\n  XML_CHARKEY,\n  XmlOptions,\n} from \"./interfaces\";\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  RestError,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\n\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n\n/**\n * Options to configure API response deserialization.\n */\nexport interface DeserializationPolicyOptions {\n  /**\n   * Configures the expected content types for the deserialization of\n   * JSON and XML response bodies.\n   */\n  expectedContentTypes?: DeserializationContentTypes;\n\n  /**\n   * A function that is able to parse XML. Required for XML support.\n   */\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>;\n\n  /**\n   * Configures behavior of xml parser and builder.\n   */\n  serializerOptions?: SerializerOptions;\n}\n\n/**\n * The content-types that will indicate that an operation response should be deserialized in a\n * particular way.\n */\nexport interface DeserializationContentTypes {\n  /**\n   * The content-types that indicate that an operation response should be deserialized as JSON.\n   * Defaults to [ \"application/json\", \"text/json\" ].\n   */\n  json?: string[];\n\n  /**\n   * The content-types that indicate that an operation response should be deserialized as XML.\n   * Defaults to [ \"application/xml\", \"application/atom+xml\" ].\n   */\n  xml?: string[];\n}\n\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options: DeserializationPolicyOptions = {}): PipelinePolicy {\n  const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;\n  const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;\n  const parseXML = options.parseXML;\n  const serializerOptions = options.serializerOptions;\n  const updatedOptions: RequiredSerializerOptions = {\n    xml: {\n      rootName: serializerOptions?.xml.rootName ?? \"\",\n      includeRoot: serializerOptions?.xml.includeRoot ?? false,\n      xmlCharKey: serializerOptions?.xml.xmlCharKey ?? XML_CHARKEY,\n    },\n  };\n\n  return {\n    name: deserializationPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return deserializeResponseBody(\n        jsonContentTypes,\n        xmlContentTypes,\n        response,\n        updatedOptions,\n        parseXML,\n      );\n    },\n  };\n}\n\nfunction getOperationResponseMap(\n  parsedResponse: PipelineResponse,\n): undefined | OperationResponseMap {\n  let result: OperationResponseMap | undefined;\n  const request: OperationRequest = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const operationSpec = operationInfo?.operationSpec;\n  if (operationSpec) {\n    if (!operationInfo?.operationResponseGetter) {\n      result = operationSpec.responses[parsedResponse.status];\n    } else {\n      result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);\n    }\n  }\n  return result;\n}\n\nfunction shouldDeserializeResponse(parsedResponse: PipelineResponse): boolean {\n  const request: OperationRequest = parsedResponse.request;\n  const operationInfo = getOperationRequestInfo(request);\n  const shouldDeserialize = operationInfo?.shouldDeserialize;\n  let result: boolean;\n  if (shouldDeserialize === undefined) {\n    result = true;\n  } else if (typeof shouldDeserialize === \"boolean\") {\n    result = shouldDeserialize;\n  } else {\n    result = shouldDeserialize(parsedResponse);\n  }\n  return result;\n}\n\nasync function deserializeResponseBody(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  response: PipelineResponse,\n  options: RequiredSerializerOptions,\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>,\n): Promise<PipelineResponse> {\n  const parsedResponse = await parse(\n    jsonContentTypes,\n    xmlContentTypes,\n    response,\n    options,\n    parseXML,\n  );\n  if (!shouldDeserializeResponse(parsedResponse)) {\n    return parsedResponse;\n  }\n\n  const operationInfo = getOperationRequestInfo(parsedResponse.request);\n  const operationSpec = operationInfo?.operationSpec;\n  if (!operationSpec || !operationSpec.responses) {\n    return parsedResponse;\n  }\n\n  const responseSpec = getOperationResponseMap(parsedResponse);\n  const { error, shouldReturnResponse } = handleErrorResponse(\n    parsedResponse,\n    operationSpec,\n    responseSpec,\n    options,\n  );\n  if (error) {\n    throw error;\n  } else if (shouldReturnResponse) {\n    return parsedResponse;\n  }\n\n  // An operation response spec does exist for current status code, so\n  // use it to deserialize the response.\n  if (responseSpec) {\n    if (responseSpec.bodyMapper) {\n      let valueToDeserialize: any = parsedResponse.parsedBody;\n      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n        valueToDeserialize =\n          typeof valueToDeserialize === \"object\"\n            ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName!]\n            : [];\n      }\n      try {\n        parsedResponse.parsedBody = operationSpec.serializer.deserialize(\n          responseSpec.bodyMapper,\n          valueToDeserialize,\n          \"operationRes.parsedBody\",\n          options,\n        );\n      } catch (deserializeError: any) {\n        const restError = new RestError(\n          `Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`,\n          {\n            statusCode: parsedResponse.status,\n            request: parsedResponse.request,\n            response: parsedResponse,\n          },\n        );\n        throw restError;\n      }\n    } else if (operationSpec.httpMethod === \"HEAD\") {\n      // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n    }\n\n    if (responseSpec.headersMapper) {\n      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(\n        responseSpec.headersMapper,\n        parsedResponse.headers.toJSON(),\n        \"operationRes.parsedHeaders\",\n        { xml: {}, ignoreUnknownProperties: true },\n      );\n    }\n  }\n\n  return parsedResponse;\n}\n\nfunction isOperationSpecEmpty(operationSpec: OperationSpec): boolean {\n  const expectedStatusCodes = Object.keys(operationSpec.responses);\n  return (\n    expectedStatusCodes.length === 0 ||\n    (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\")\n  );\n}\n\nfunction handleErrorResponse(\n  parsedResponse: FullOperationResponse,\n  operationSpec: OperationSpec,\n  responseSpec: OperationResponseMap | undefined,\n  options: RequiredSerializerOptions,\n): { error: RestError | null; shouldReturnResponse: boolean } {\n  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n  const isExpectedStatusCode: boolean = isOperationSpecEmpty(operationSpec)\n    ? isSuccessByStatus\n    : !!responseSpec;\n\n  if (isExpectedStatusCode) {\n    if (responseSpec) {\n      if (!responseSpec.isError) {\n        return { error: null, shouldReturnResponse: false };\n      }\n    } else {\n      return { error: null, shouldReturnResponse: false };\n    }\n  }\n\n  const errorResponseSpec = responseSpec ?? operationSpec.responses.default;\n\n  const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(\n    parsedResponse.status,\n  )\n    ? `Unexpected status code: ${parsedResponse.status}`\n    : (parsedResponse.bodyAsText as string);\n\n  const error = new RestError(initialErrorMessage, {\n    statusCode: parsedResponse.status,\n    request: parsedResponse.request,\n    response: parsedResponse,\n  });\n\n  // If the item failed but there's no error spec or default spec to deserialize the error,\n  // we should fail so we just throw the parsed response\n  if (!errorResponseSpec) {\n    throw error;\n  }\n\n  const defaultBodyMapper = errorResponseSpec.bodyMapper;\n  const defaultHeadersMapper = errorResponseSpec.headersMapper;\n\n  try {\n    // If error response has a body, try to deserialize it using default body mapper.\n    // Then try to extract error code & message from it\n    if (parsedResponse.parsedBody) {\n      const parsedBody = parsedResponse.parsedBody;\n      let deserializedError;\n\n      if (defaultBodyMapper) {\n        let valueToDeserialize: any = parsedBody;\n        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n          valueToDeserialize = [];\n          const elementName = defaultBodyMapper.xmlElementName;\n          if (typeof parsedBody === \"object\" && elementName) {\n            valueToDeserialize = parsedBody[elementName];\n          }\n        }\n        deserializedError = operationSpec.serializer.deserialize(\n          defaultBodyMapper,\n          valueToDeserialize,\n          \"error.response.parsedBody\",\n          options,\n        );\n      }\n\n      const internalError: any = parsedBody.error || deserializedError || parsedBody;\n      error.code = internalError.code;\n      if (internalError.message) {\n        error.message = internalError.message;\n      }\n\n      if (defaultBodyMapper) {\n        (error.response! as FullOperationResponse).parsedBody = deserializedError;\n      }\n    }\n\n    // If error response has headers, try to deserialize it using default header mapper\n    if (parsedResponse.headers && defaultHeadersMapper) {\n      (error.response! as FullOperationResponse).parsedHeaders =\n        operationSpec.serializer.deserialize(\n          defaultHeadersMapper,\n          parsedResponse.headers.toJSON(),\n          \"operationRes.parsedHeaders\",\n        );\n    }\n  } catch (defaultError: any) {\n    error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n  }\n\n  return { error, shouldReturnResponse: false };\n}\n\nasync function parse(\n  jsonContentTypes: string[],\n  xmlContentTypes: string[],\n  operationResponse: FullOperationResponse,\n  opts: RequiredSerializerOptions,\n  parseXML?: (str: string, opts?: XmlOptions) => Promise<any>,\n): Promise<FullOperationResponse> {\n  if (\n    !operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) &&\n    operationResponse.bodyAsText\n  ) {\n    const text = operationResponse.bodyAsText;\n    const contentType: string = operationResponse.headers.get(\"Content-Type\") || \"\";\n    const contentComponents: string[] = !contentType\n      ? []\n      : contentType.split(\";\").map((component) => component.toLowerCase());\n\n    try {\n      if (\n        contentComponents.length === 0 ||\n        contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)\n      ) {\n        operationResponse.parsedBody = JSON.parse(text);\n        return operationResponse;\n      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n        if (!parseXML) {\n          throw new Error(\"Parsing XML not supported.\");\n        }\n        const body = await parseXML(text, opts.xml);\n        operationResponse.parsedBody = body;\n        return operationResponse;\n      }\n    } catch (err: any) {\n      const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n      const errCode = err.code || RestError.PARSE_ERROR;\n      const e = new RestError(msg, {\n        code: errCode,\n        statusCode: operationResponse.status,\n        request: operationResponse.request,\n        response: operationResponse,\n      });\n      throw e;\n    }\n  }\n\n  return operationResponse;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationParameter, OperationSpec } from \"./interfaces\";\nimport { MapperTypeNames } from \"./serializer\";\n\n/**\n * Gets the list of status codes for streaming responses.\n * @internal\n */\nexport function getStreamingResponseStatusCodes(operationSpec: OperationSpec): Set<number> {\n  const result = new Set<number>();\n  for (const statusCode in operationSpec.responses) {\n    const operationResponse = operationSpec.responses[statusCode];\n    if (\n      operationResponse.bodyMapper &&\n      operationResponse.bodyMapper.type.name === MapperTypeNames.Stream\n    ) {\n      result.add(Number(statusCode));\n    }\n  }\n  return result;\n}\n\n/**\n * Get the path to this parameter's value as a dotted string (a.b.c).\n * @param parameter - The parameter to get the path string for.\n * @returns The path to this parameter's value as a dotted string.\n * @internal\n */\nexport function getPathStringFromParameter(parameter: OperationParameter): string {\n  const { parameterPath, mapper } = parameter;\n  let result: string;\n  if (typeof parameterPath === \"string\") {\n    result = parameterPath;\n  } else if (Array.isArray(parameterPath)) {\n    result = parameterPath.join(\".\");\n  } else {\n    result = mapper.serializedName!;\n  }\n  return result;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  DictionaryMapper,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n  RequiredSerializerOptions,\n  SerializerOptions,\n  XML_ATTRKEY,\n  XML_CHARKEY,\n  XmlOptions,\n} from \"./interfaces\";\nimport { PipelinePolicy, PipelineResponse, SendRequest } from \"@azure/core-rest-pipeline\";\nimport {\n  getOperationArgumentValueFromParameter,\n  getOperationRequestInfo,\n} from \"./operationHelpers\";\nimport { MapperTypeNames } from \"./serializer\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n\n/**\n * Options to configure API request serialization.\n */\nexport interface SerializationPolicyOptions {\n  /**\n   * A function that is able to write XML. Required for XML support.\n   */\n  stringifyXML?: (obj: any, opts?: XmlOptions) => string;\n\n  /**\n   * Configures behavior of xml parser and builder.\n   */\n  serializerOptions?: SerializerOptions;\n}\n\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options: SerializationPolicyOptions = {}): PipelinePolicy {\n  const stringifyXML = options.stringifyXML;\n\n  return {\n    name: serializationPolicyName,\n    async sendRequest(request: OperationRequest, next: SendRequest): Promise<PipelineResponse> {\n      const operationInfo = getOperationRequestInfo(request);\n      const operationSpec = operationInfo?.operationSpec;\n      const operationArguments = operationInfo?.operationArguments;\n      if (operationSpec && operationArguments) {\n        serializeHeaders(request, operationArguments, operationSpec);\n        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n      }\n      return next(request);\n    },\n  };\n}\n\n/**\n * @internal\n */\nexport function serializeHeaders(\n  request: OperationRequest,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec,\n): void {\n  if (operationSpec.headerParameters) {\n    for (const headerParameter of operationSpec.headerParameters) {\n      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n      if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n        headerValue = operationSpec.serializer.serialize(\n          headerParameter.mapper,\n          headerValue,\n          getPathStringFromParameter(headerParameter),\n        );\n        const headerCollectionPrefix = (headerParameter.mapper as DictionaryMapper)\n          .headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n          for (const key of Object.keys(headerValue)) {\n            request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n          }\n        } else {\n          request.headers.set(\n            headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter),\n            headerValue,\n          );\n        }\n      }\n    }\n  }\n  const customHeaders = operationArguments.options?.requestOptions?.customHeaders;\n  if (customHeaders) {\n    for (const customHeaderName of Object.keys(customHeaders)) {\n      request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function serializeRequestBody(\n  request: OperationRequest,\n  operationArguments: OperationArguments,\n  operationSpec: OperationSpec,\n  stringifyXML: (obj: any, opts?: XmlOptions) => string = function () {\n    throw new Error(\"XML serialization unsupported!\");\n  },\n): void {\n  const serializerOptions = operationArguments.options?.serializerOptions;\n  const updatedOptions: RequiredSerializerOptions = {\n    xml: {\n      rootName: serializerOptions?.xml.rootName ?? \"\",\n      includeRoot: serializerOptions?.xml.includeRoot ?? false,\n      xmlCharKey: serializerOptions?.xml.xmlCharKey ?? XML_CHARKEY,\n    },\n  };\n\n  const xmlCharKey = updatedOptions.xml.xmlCharKey;\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    request.body = getOperationArgumentValueFromParameter(\n      operationArguments,\n      operationSpec.requestBody,\n    );\n\n    const bodyMapper = operationSpec.requestBody.mapper;\n    const {\n      required,\n      serializedName,\n      xmlName,\n      xmlElementName,\n      xmlNamespace,\n      xmlNamespacePrefix,\n      nullable,\n    } = bodyMapper;\n    const typeName = bodyMapper.type.name;\n\n    try {\n      if (\n        (request.body !== undefined && request.body !== null) ||\n        (nullable && request.body === null) ||\n        required\n      ) {\n        const requestBodyParameterPathString: string = getPathStringFromParameter(\n          operationSpec.requestBody,\n        );\n        request.body = operationSpec.serializer.serialize(\n          bodyMapper,\n          request.body,\n          requestBodyParameterPathString,\n          updatedOptions,\n        );\n\n        const isStream = typeName === MapperTypeNames.Stream;\n\n        if (operationSpec.isXML) {\n          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n          const value = getXmlValueWithNamespace(\n            xmlNamespace,\n            xmlnsKey,\n            typeName,\n            request.body,\n            updatedOptions,\n          );\n\n          if (typeName === MapperTypeNames.Sequence) {\n            request.body = stringifyXML(\n              prepareXMLRootList(\n                value,\n                xmlElementName || xmlName || serializedName!,\n                xmlnsKey,\n                xmlNamespace,\n              ),\n              { rootName: xmlName || serializedName, xmlCharKey },\n            );\n          } else if (!isStream) {\n            request.body = stringifyXML(value, {\n              rootName: xmlName || serializedName,\n              xmlCharKey,\n            });\n          }\n        } else if (\n          typeName === MapperTypeNames.String &&\n          (operationSpec.contentType?.match(\"text/plain\") || operationSpec.mediaType === \"text\")\n        ) {\n          // the String serializer has validated that request body is a string\n          // so just send the string.\n          return;\n        } else if (!isStream) {\n          request.body = JSON.stringify(request.body);\n        }\n      }\n    } catch (error: any) {\n      throw new Error(\n        `Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(\n          serializedName,\n          undefined,\n          \"  \",\n        )}.`,\n      );\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    request.formData = {};\n    for (const formDataParameter of operationSpec.formDataParameters) {\n      const formDataParameterValue = getOperationArgumentValueFromParameter(\n        operationArguments,\n        formDataParameter,\n      );\n      if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n        const formDataParameterPropertyName: string =\n          formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(\n          formDataParameter.mapper,\n          formDataParameterValue,\n          getPathStringFromParameter(formDataParameter),\n          updatedOptions,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(\n  xmlNamespace: string | undefined,\n  xmlnsKey: string,\n  typeName: string,\n  serializedValue: any,\n  options: RequiredSerializerOptions,\n): any {\n  // Composite and Sequence schemas already got their root namespace set during serialization\n  // We just need to add xmlns to the other schema types\n  if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n    const result: any = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n    return result;\n  }\n\n  return serializedValue;\n}\n\nfunction prepareXMLRootList(\n  obj: any,\n  elementName: string,\n  xmlNamespaceKey?: string,\n  xmlNamespace?: string,\n): { [key: string]: any[] } {\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n  if (!xmlNamespaceKey || !xmlNamespace) {\n    return { [elementName]: obj };\n  }\n\n  const result = { [elementName]: obj };\n  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n  return result;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeserializationPolicyOptions, deserializationPolicy } from \"./deserializationPolicy\";\nimport {\n  InternalPipelineOptions,\n  Pipeline,\n  bearerTokenAuthenticationPolicy,\n  createPipelineFromOptions,\n} from \"@azure/core-rest-pipeline\";\nimport { SerializationPolicyOptions, serializationPolicy } from \"./serializationPolicy\";\nimport { TokenCredential } from \"@azure/core-auth\";\n\n/**\n * Options for creating a Pipeline to use with ServiceClient.\n * Mostly for customizing the auth policy (if using token auth) or\n * the deserialization options when using XML.\n */\nexport interface InternalClientPipelineOptions extends InternalPipelineOptions {\n  /**\n   * Options to customize bearerTokenAuthenticationPolicy.\n   */\n  credentialOptions?: { credentialScopes: string | string[]; credential: TokenCredential };\n  /**\n   * Options to customize deserializationPolicy.\n   */\n  deserializationOptions?: DeserializationPolicyOptions;\n  /**\n   * Options to customize serializationPolicy.\n   */\n  serializationOptions?: SerializationPolicyOptions;\n}\n\n/**\n * Creates a new Pipeline for use with a Service Client.\n * Adds in deserializationPolicy by default.\n * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.\n * @param options - Options to customize the created pipeline.\n */\nexport function createClientPipeline(options: InternalClientPipelineOptions = {}): Pipeline {\n  const pipeline = createPipelineFromOptions(options ?? {});\n  if (options.credentialOptions) {\n    pipeline.addPolicy(\n      bearerTokenAuthenticationPolicy({\n        credential: options.credentialOptions.credential,\n        scopes: options.credentialOptions.credentialScopes,\n      }),\n    );\n  }\n\n  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: \"Serialize\" });\n  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {\n    phase: \"Deserialize\",\n  });\n\n  return pipeline;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpClient, createDefaultHttpClient } from \"@azure/core-rest-pipeline\";\n\nlet cachedHttpClient: HttpClient | undefined;\n\nexport function getCachedDefaultHttpClient(): HttpClient {\n  if (!cachedHttpClient) {\n    cachedHttpClient = createDefaultHttpClient();\n  }\n\n  return cachedHttpClient;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationArguments, OperationSpec, QueryCollectionFormat } from \"./interfaces\";\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers\";\n\nconst CollectionFormatToDelimiterMap: { [key in QueryCollectionFormat]: string } = {\n  CSV: \",\",\n  SSV: \" \",\n  Multi: \"Multi\",\n  TSV: \"\\t\",\n  Pipes: \"|\",\n};\n\nexport function getRequestUrl(\n  baseUri: string,\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any },\n): string {\n  const urlReplacements = calculateUrlReplacements(\n    operationSpec,\n    operationArguments,\n    fallbackObject,\n  );\n\n  let isAbsolutePath = false;\n\n  let requestUrl = replaceAll(baseUri, urlReplacements);\n  if (operationSpec.path) {\n    let path = replaceAll(operationSpec.path, urlReplacements);\n    // QUIRK: sometimes we get a path component like /{nextLink}\n    // which may be a fully formed URL with a leading /. In that case, we should\n    // remove the leading /\n    if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n      path = path.substring(1);\n    }\n    // QUIRK: sometimes we get a path component like {nextLink}\n    // which may be a fully formed URL. In that case, we should\n    // ignore the baseUri.\n    if (isAbsoluteUrl(path)) {\n      requestUrl = path;\n      isAbsolutePath = true;\n    } else {\n      requestUrl = appendPath(requestUrl, path);\n    }\n  }\n\n  const { queryParams, sequenceParams } = calculateQueryParameters(\n    operationSpec,\n    operationArguments,\n    fallbackObject,\n  );\n  /**\n   * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n   * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n   * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n   * is still being built so there is nothing to overwrite.\n   */\n  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n\n  return requestUrl;\n}\n\nfunction replaceAll(input: string, replacements: Map<string, string>): string {\n  let result = input;\n  for (const [searchValue, replaceValue] of replacements) {\n    result = result.split(searchValue).join(replaceValue);\n  }\n  return result;\n}\n\nfunction calculateUrlReplacements(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any },\n): Map<string, string> {\n  const result = new Map<string, string>();\n  if (operationSpec.urlParameters?.length) {\n    for (const urlParameter of operationSpec.urlParameters) {\n      let urlParameterValue: string = getOperationArgumentValueFromParameter(\n        operationArguments,\n        urlParameter,\n        fallbackObject,\n      );\n      const parameterPathString = getPathStringFromParameter(urlParameter);\n      urlParameterValue = operationSpec.serializer.serialize(\n        urlParameter.mapper,\n        urlParameterValue,\n        parameterPathString,\n      );\n      if (!urlParameter.skipEncoding) {\n        urlParameterValue = encodeURIComponent(urlParameterValue);\n      }\n      result.set(\n        `{${urlParameter.mapper.serializedName || parameterPathString}}`,\n        urlParameterValue,\n      );\n    }\n  }\n  return result;\n}\n\nfunction isAbsoluteUrl(url: string): boolean {\n  return url.includes(\"://\");\n}\n\nfunction appendPath(url: string, pathToAppend?: string): string {\n  if (!pathToAppend) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n  let newPath = parsedUrl.pathname;\n\n  if (!newPath.endsWith(\"/\")) {\n    newPath = `${newPath}/`;\n  }\n\n  if (pathToAppend.startsWith(\"/\")) {\n    pathToAppend = pathToAppend.substring(1);\n  }\n\n  const searchStart = pathToAppend.indexOf(\"?\");\n  if (searchStart !== -1) {\n    const path = pathToAppend.substring(0, searchStart);\n    const search = pathToAppend.substring(searchStart + 1);\n    newPath = newPath + path;\n    if (search) {\n      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n    }\n  } else {\n    newPath = newPath + pathToAppend;\n  }\n\n  parsedUrl.pathname = newPath;\n\n  return parsedUrl.toString();\n}\n\nfunction calculateQueryParameters(\n  operationSpec: OperationSpec,\n  operationArguments: OperationArguments,\n  fallbackObject: { [parameterName: string]: any },\n): {\n  queryParams: Map<string, string | string[]>;\n  sequenceParams: Set<string>;\n} {\n  const result = new Map<string, string | string[]>();\n  const sequenceParams: Set<string> = new Set<string>();\n\n  if (operationSpec.queryParameters?.length) {\n    for (const queryParameter of operationSpec.queryParameters) {\n      if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n        sequenceParams.add(queryParameter.mapper.serializedName);\n      }\n      let queryParameterValue: string | string[] = getOperationArgumentValueFromParameter(\n        operationArguments,\n        queryParameter,\n        fallbackObject,\n      );\n      if (\n        (queryParameterValue !== undefined && queryParameterValue !== null) ||\n        queryParameter.mapper.required\n      ) {\n        queryParameterValue = operationSpec.serializer.serialize(\n          queryParameter.mapper,\n          queryParameterValue,\n          getPathStringFromParameter(queryParameter),\n        );\n\n        const delimiter = queryParameter.collectionFormat\n          ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n          : \"\";\n        if (Array.isArray(queryParameterValue)) {\n          // replace null and undefined\n          queryParameterValue = queryParameterValue.map((item) => {\n            if (item === null || item === undefined) {\n              return \"\";\n            }\n\n            return item;\n          });\n        }\n        if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n          continue;\n        } else if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n        if (!queryParameter.skipEncoding) {\n          if (Array.isArray(queryParameterValue)) {\n            queryParameterValue = queryParameterValue.map((item: string) => {\n              return encodeURIComponent(item);\n            });\n          } else {\n            queryParameterValue = encodeURIComponent(queryParameterValue);\n          }\n        }\n\n        // Join pipes and CSV *after* encoding, or the server will be upset.\n        if (\n          Array.isArray(queryParameterValue) &&\n          (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")\n        ) {\n          queryParameterValue = queryParameterValue.join(delimiter);\n        }\n\n        result.set(\n          queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter),\n          queryParameterValue,\n        );\n      }\n    }\n  }\n  return {\n    queryParams: result,\n    sequenceParams,\n  };\n}\n\nfunction simpleParseQueryParams(queryString: string): Map<string, string | string[] | undefined> {\n  const result: Map<string, string | string[] | undefined> = new Map<\n    string,\n    string | string[] | undefined\n  >();\n  if (!queryString || queryString[0] !== \"?\") {\n    return result;\n  }\n\n  // remove the leading ?\n  queryString = queryString.slice(1);\n  const pairs = queryString.split(\"&\");\n\n  for (const pair of pairs) {\n    const [name, value] = pair.split(\"=\", 2);\n    const existingValue = result.get(name);\n    if (existingValue) {\n      if (Array.isArray(existingValue)) {\n        existingValue.push(value);\n      } else {\n        result.set(name, [existingValue, value]);\n      }\n    } else {\n      result.set(name, value);\n    }\n  }\n\n  return result;\n}\n\n/** @internal */\nexport function appendQueryParams(\n  url: string,\n  queryParams: Map<string, string | string[]>,\n  sequenceParams: Set<string>,\n  noOverwrite: boolean = false,\n): string {\n  if (queryParams.size === 0) {\n    return url;\n  }\n\n  const parsedUrl = new URL(url);\n\n  // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n  // can change their meaning to the server, such as in the case of a SAS signature.\n  // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n  const combinedParams = simpleParseQueryParams(parsedUrl.search);\n\n  for (const [name, value] of queryParams) {\n    const existingValue = combinedParams.get(name);\n    if (Array.isArray(existingValue)) {\n      if (Array.isArray(value)) {\n        existingValue.push(...value);\n        const valueSet = new Set(existingValue);\n        combinedParams.set(name, Array.from(valueSet));\n      } else {\n        existingValue.push(value);\n      }\n    } else if (existingValue) {\n      if (Array.isArray(value)) {\n        value.unshift(existingValue);\n      } else if (sequenceParams.has(name)) {\n        combinedParams.set(name, [existingValue, value]);\n      }\n      if (!noOverwrite) {\n        combinedParams.set(name, value);\n      }\n    } else {\n      combinedParams.set(name, value);\n    }\n  }\n\n  const searchPieces: string[] = [];\n  for (const [name, value] of combinedParams) {\n    if (typeof value === \"string\") {\n      searchPieces.push(`${name}=${value}`);\n    } else if (Array.isArray(value)) {\n      // QUIRK: If we get an array of values, include multiple key/value pairs\n      for (const subValue of value) {\n        searchPieces.push(`${name}=${subValue}`);\n      }\n    } else {\n      searchPieces.push(`${name}=${value}`);\n    }\n  }\n\n  // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n  parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n  return parsedUrl.toString();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-client\");\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommonClientOptions,\n  OperationArguments,\n  OperationRequest,\n  OperationSpec,\n} from \"./interfaces\";\nimport {\n  HttpClient,\n  Pipeline,\n  PipelineRequest,\n  PipelineResponse,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { createClientPipeline } from \"./pipeline\";\nimport { flattenResponse } from \"./utils\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache\";\nimport { getOperationRequestInfo } from \"./operationHelpers\";\nimport { getRequestUrl } from \"./urlHelpers\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers\";\nimport { logger } from \"./log\";\n\n/**\n * Options to be provided while creating the client.\n */\nexport interface ServiceClientOptions extends CommonClientOptions {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * @deprecated This property is deprecated and will be removed soon, please use endpoint instead\n   */\n  baseUri?: string;\n  /**\n   * If specified, this is the endpoint that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   * to encourage customer to use endpoint, we mark the baseUri as deprecated.\n   */\n  endpoint?: string;\n  /**\n   * If specified, will be used to build the BearerTokenAuthenticationPolicy.\n   */\n  credentialScopes?: string | string[];\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  requestContentType?: string;\n  /**\n   * Credential used to authenticate the request.\n   */\n  credential?: TokenCredential;\n  /**\n   * A customized pipeline to use, otherwise a default one will be created.\n   */\n  pipeline?: Pipeline;\n}\n\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n  /**\n   * If specified, this is the base URI that requests will be made against for this ServiceClient.\n   * If it is not specified, then all OperationSpecs must contain a baseUrl property.\n   */\n  private readonly _endpoint?: string;\n\n  /**\n   * The default request content type for the service.\n   * Used if no requestContentType is present on an OperationSpec.\n   */\n  private readonly _requestContentType?: string;\n\n  /**\n   * Set to true if the request is sent over HTTP instead of HTTPS\n   */\n  private readonly _allowInsecureConnection?: boolean;\n\n  /**\n   * The HTTP client that will be used to send requests.\n   */\n  private readonly _httpClient: HttpClient;\n\n  /**\n   * The pipeline used by this client to make requests\n   */\n  public readonly pipeline: Pipeline;\n\n  /**\n   * The ServiceClient constructor\n   * @param credential - The credentials used for authentication with the service.\n   * @param options - The service client options that govern the behavior of the client.\n   */\n  constructor(options: ServiceClientOptions = {}) {\n    this._requestContentType = options.requestContentType;\n    this._endpoint = options.endpoint ?? options.baseUri;\n    if (options.baseUri) {\n      logger.warning(\n        \"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\",\n      );\n    }\n    this._allowInsecureConnection = options.allowInsecureConnection;\n    this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n\n    this.pipeline = options.pipeline || createDefaultPipeline(options);\n    if (options.additionalPolicies?.length) {\n      for (const { policy, position } of options.additionalPolicies) {\n        // Sign happens after Retry and is commonly needed to occur\n        // before policies that intercept post-retry.\n        const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n        this.pipeline.addPolicy(policy, {\n          afterPhase,\n        });\n      }\n    }\n  }\n\n  /**\n   * Send the provided httpRequest.\n   */\n  async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    return this.pipeline.sendRequest(this._httpClient, request);\n  }\n\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @typeParam T - The typed result of the request, based on the OperationSpec.\n   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n   * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n   */\n  async sendOperationRequest<T>(\n    operationArguments: OperationArguments,\n    operationSpec: OperationSpec,\n  ): Promise<T> {\n    const endpoint: string | undefined = operationSpec.baseUrl || this._endpoint;\n    if (!endpoint) {\n      throw new Error(\n        \"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\",\n      );\n    }\n\n    // Templatized URLs sometimes reference properties on the ServiceClient child class,\n    // so we have to pass `this` below in order to search these properties if they're\n    // not part of OperationArguments\n    const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n\n    const request: OperationRequest = createPipelineRequest({\n      url,\n    });\n    request.method = operationSpec.httpMethod;\n    const operationInfo = getOperationRequestInfo(request);\n    operationInfo.operationSpec = operationSpec;\n    operationInfo.operationArguments = operationArguments;\n\n    const contentType = operationSpec.contentType || this._requestContentType;\n    if (contentType && operationSpec.requestBody) {\n      request.headers.set(\"Content-Type\", contentType);\n    }\n\n    const options = operationArguments.options;\n    if (options) {\n      const requestOptions = options.requestOptions;\n\n      if (requestOptions) {\n        if (requestOptions.timeout) {\n          request.timeout = requestOptions.timeout;\n        }\n\n        if (requestOptions.onUploadProgress) {\n          request.onUploadProgress = requestOptions.onUploadProgress;\n        }\n\n        if (requestOptions.onDownloadProgress) {\n          request.onDownloadProgress = requestOptions.onDownloadProgress;\n        }\n\n        if (requestOptions.shouldDeserialize !== undefined) {\n          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n        }\n\n        if (requestOptions.allowInsecureConnection) {\n          request.allowInsecureConnection = true;\n        }\n      }\n\n      if (options.abortSignal) {\n        request.abortSignal = options.abortSignal;\n      }\n\n      if (options.tracingOptions) {\n        request.tracingOptions = options.tracingOptions;\n      }\n    }\n\n    if (this._allowInsecureConnection) {\n      request.allowInsecureConnection = true;\n    }\n\n    if (request.streamResponseStatusCodes === undefined) {\n      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n    }\n\n    try {\n      const rawResponse = await this.sendRequest(request);\n      const flatResponse = flattenResponse(\n        rawResponse,\n        operationSpec.responses[rawResponse.status],\n      ) as T;\n      if (options?.onResponse) {\n        options.onResponse(rawResponse, flatResponse);\n      }\n      return flatResponse;\n    } catch (error: any) {\n      if (typeof error === \"object\" && error?.response) {\n        const rawResponse = error.response;\n        const flatResponse = flattenResponse(\n          rawResponse,\n          operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"],\n        );\n        error.details = flatResponse;\n        if (options?.onResponse) {\n          options.onResponse(rawResponse, flatResponse, error);\n        }\n      }\n      throw error;\n    }\n  }\n}\n\nfunction createDefaultPipeline(options: ServiceClientOptions): Pipeline {\n  const credentialScopes = getCredentialScopes(options);\n  const credentialOptions =\n    options.credential && credentialScopes\n      ? { credentialScopes, credential: options.credential }\n      : undefined;\n\n  return createClientPipeline({\n    ...options,\n    credentialOptions,\n  });\n}\n\nfunction getCredentialScopes(options: ServiceClientOptions): string | string[] | undefined {\n  if (options.credentialScopes) {\n    return options.credentialScopes;\n  }\n\n  if (options.endpoint) {\n    return `${options.endpoint}/.default`;\n  }\n\n  if (options.baseUri) {\n    return `${options.baseUri}/.default`;\n  }\n\n  if (options.credential && !options.credentialScopes) {\n    throw new Error(\n      `When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`,\n    );\n  }\n\n  return undefined;\n}\n", "/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreClient from \"@azure/core-client\";\n\nexport const JobDescriptor: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"JobDescriptor\",\n    modelProperties: {\n      displayName: {\n        serializedName: \"displayName\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const AnalysisInput: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalysisInput\",\n    modelProperties: {\n      analysisInput: {\n        serializedName: \"analysisInput\",\n        type: {\n          name: \"Composite\",\n          className: \"MultiLanguageBatchInput\"\n        }\n      }\n    }\n  }\n};\n\nexport const MultiLanguageBatchInput: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"MultiLanguageBatchInput\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextDocumentInput\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const TextDocumentInput: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextDocumentInput\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      language: {\n        serializedName: \"language\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const JobManifest: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"JobManifest\",\n    modelProperties: {\n      tasks: {\n        serializedName: \"tasks\",\n        type: {\n          name: \"Composite\",\n          className: \"JobManifestTasks\"\n        }\n      }\n    }\n  }\n};\n\nexport const JobManifestTasks: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"JobManifestTasks\",\n    modelProperties: {\n      entityRecognitionTasks: {\n        serializedName: \"entityRecognitionTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"EntitiesTask\"\n            }\n          }\n        }\n      },\n      entityRecognitionPiiTasks: {\n        serializedName: \"entityRecognitionPiiTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"PiiTask\"\n            }\n          }\n        }\n      },\n      keyPhraseExtractionTasks: {\n        serializedName: \"keyPhraseExtractionTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"KeyPhrasesTask\"\n            }\n          }\n        }\n      },\n      entityLinkingTasks: {\n        serializedName: \"entityLinkingTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"EntityLinkingTask\"\n            }\n          }\n        }\n      },\n      sentimentAnalysisTasks: {\n        serializedName: \"sentimentAnalysisTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SentimentAnalysisTask\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const EntitiesTask: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntitiesTask\",\n    modelProperties: {\n      parameters: {\n        serializedName: \"parameters\",\n        type: {\n          name: \"Composite\",\n          className: \"EntitiesTaskParameters\"\n        }\n      }\n    }\n  }\n};\n\nexport const EntitiesTaskParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntitiesTaskParameters\",\n    modelProperties: {\n      modelVersion: {\n        defaultValue: \"latest\",\n        serializedName: \"model-version\",\n        type: {\n          name: \"String\"\n        }\n      },\n      loggingOptOut: {\n        serializedName: \"loggingOptOut\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      stringIndexType: {\n        serializedName: \"stringIndexType\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const PiiTask: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"PiiTask\",\n    modelProperties: {\n      parameters: {\n        serializedName: \"parameters\",\n        type: {\n          name: \"Composite\",\n          className: \"PiiTaskParameters\"\n        }\n      }\n    }\n  }\n};\n\nexport const PiiTaskParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"PiiTaskParameters\",\n    modelProperties: {\n      domain: {\n        defaultValue: \"none\",\n        serializedName: \"domain\",\n        type: {\n          name: \"String\"\n        }\n      },\n      modelVersion: {\n        defaultValue: \"latest\",\n        serializedName: \"model-version\",\n        type: {\n          name: \"String\"\n        }\n      },\n      loggingOptOut: {\n        defaultValue: true,\n        serializedName: \"loggingOptOut\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      piiCategories: {\n        constraints: {\n          UniqueItems: true\n        },\n        serializedName: \"piiCategories\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      stringIndexType: {\n        serializedName: \"stringIndexType\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyPhrasesTask: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyPhrasesTask\",\n    modelProperties: {\n      parameters: {\n        serializedName: \"parameters\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyPhrasesTaskParameters\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyPhrasesTaskParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyPhrasesTaskParameters\",\n    modelProperties: {\n      modelVersion: {\n        defaultValue: \"latest\",\n        serializedName: \"model-version\",\n        type: {\n          name: \"String\"\n        }\n      },\n      loggingOptOut: {\n        serializedName: \"loggingOptOut\",\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const EntityLinkingTask: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntityLinkingTask\",\n    modelProperties: {\n      parameters: {\n        serializedName: \"parameters\",\n        type: {\n          name: \"Composite\",\n          className: \"EntityLinkingTaskParameters\"\n        }\n      }\n    }\n  }\n};\n\nexport const EntityLinkingTaskParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntityLinkingTaskParameters\",\n    modelProperties: {\n      modelVersion: {\n        defaultValue: \"latest\",\n        serializedName: \"model-version\",\n        type: {\n          name: \"String\"\n        }\n      },\n      loggingOptOut: {\n        serializedName: \"loggingOptOut\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      stringIndexType: {\n        serializedName: \"stringIndexType\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const SentimentAnalysisTask: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentimentAnalysisTask\",\n    modelProperties: {\n      parameters: {\n        serializedName: \"parameters\",\n        type: {\n          name: \"Composite\",\n          className: \"SentimentAnalysisTaskParameters\"\n        }\n      }\n    }\n  }\n};\n\nexport const SentimentAnalysisTaskParameters: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentimentAnalysisTaskParameters\",\n    modelProperties: {\n      modelVersion: {\n        defaultValue: \"latest\",\n        serializedName: \"model-version\",\n        type: {\n          name: \"String\"\n        }\n      },\n      loggingOptOut: {\n        serializedName: \"loggingOptOut\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      opinionMining: {\n        serializedName: \"opinionMining\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      stringIndexType: {\n        serializedName: \"stringIndexType\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorResponse: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ErrorResponse\",\n    modelProperties: {\n      error: {\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"TextAnalyticsError\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextAnalyticsError: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextAnalyticsError\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      target: {\n        serializedName: \"target\",\n        type: {\n          name: \"String\"\n        }\n      },\n      innererror: {\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"InnerError\"\n        }\n      },\n      details: {\n        serializedName: \"details\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsError\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const InnerError: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"InnerError\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      details: {\n        serializedName: \"details\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      target: {\n        serializedName: \"target\",\n        type: {\n          name: \"String\"\n        }\n      },\n      innererror: {\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"InnerError\"\n        }\n      }\n    }\n  }\n};\n\nexport const JobMetadata: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"JobMetadata\",\n    modelProperties: {\n      createdDateTime: {\n        serializedName: \"createdDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      expirationDateTime: {\n        serializedName: \"expirationDateTime\",\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      jobId: {\n        serializedName: \"jobId\",\n        required: true,\n        type: {\n          name: \"Uuid\"\n        }\n      },\n      lastUpdateDateTime: {\n        serializedName: \"lastUpdateDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      status: {\n        serializedName: \"status\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\n            \"notStarted\",\n            \"running\",\n            \"succeeded\",\n            \"failed\",\n            \"rejected\",\n            \"cancelled\",\n            \"cancelling\"\n          ]\n        }\n      }\n    }\n  }\n};\n\nexport const AnalyzeJobDisplayName: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeJobDisplayName\",\n    modelProperties: {\n      displayName: {\n        serializedName: \"displayName\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const TasksState: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksState\",\n    modelProperties: {\n      tasks: {\n        serializedName: \"tasks\",\n        type: {\n          name: \"Composite\",\n          className: \"TasksStateTasks\"\n        }\n      }\n    }\n  }\n};\n\nexport const TasksStateTasks: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksStateTasks\",\n    modelProperties: {\n      completed: {\n        serializedName: \"completed\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      failed: {\n        serializedName: \"failed\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      inProgress: {\n        serializedName: \"inProgress\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      total: {\n        serializedName: \"total\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      entityRecognitionTasks: {\n        serializedName: \"entityRecognitionTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TasksStateTasksEntityRecognitionTasksItem\"\n            }\n          }\n        }\n      },\n      entityRecognitionPiiTasks: {\n        serializedName: \"entityRecognitionPiiTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TasksStateTasksEntityRecognitionPiiTasksItem\"\n            }\n          }\n        }\n      },\n      keyPhraseExtractionTasks: {\n        serializedName: \"keyPhraseExtractionTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TasksStateTasksKeyPhraseExtractionTasksItem\"\n            }\n          }\n        }\n      },\n      entityLinkingTasks: {\n        serializedName: \"entityLinkingTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TasksStateTasksEntityLinkingTasksItem\"\n            }\n          }\n        }\n      },\n      sentimentAnalysisTasks: {\n        serializedName: \"sentimentAnalysisTasks\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TasksStateTasksSentimentAnalysisTasksItem\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const TaskState: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TaskState\",\n    modelProperties: {\n      lastUpdateDateTime: {\n        serializedName: \"lastUpdateDateTime\",\n        required: true,\n        type: {\n          name: \"DateTime\"\n        }\n      },\n      status: {\n        serializedName: \"status\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\n            \"notStarted\",\n            \"running\",\n            \"succeeded\",\n            \"failed\",\n            \"rejected\",\n            \"cancelled\",\n            \"cancelling\"\n          ]\n        }\n      }\n    }\n  }\n};\n\nexport const EntitiesTaskResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntitiesTaskResult\",\n    modelProperties: {\n      results: {\n        serializedName: \"results\",\n        type: {\n          name: \"Composite\",\n          className: \"EntitiesResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const EntitiesResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntitiesResult\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentEntities\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentEntities: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentEntities\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      entities: {\n        serializedName: \"entities\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"Entity\"\n            }\n          }\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const Entity: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Entity\",\n    modelProperties: {\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      category: {\n        serializedName: \"category\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      subCategory: {\n        serializedName: \"subcategory\",\n        type: {\n          name: \"String\"\n        }\n      },\n      offset: {\n        serializedName: \"offset\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      length: {\n        serializedName: \"length\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      confidenceScore: {\n        serializedName: \"confidenceScore\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextAnalyticsWarning: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextAnalyticsWarning\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextDocumentStatistics: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextDocumentStatistics\",\n    modelProperties: {\n      characterCount: {\n        serializedName: \"charactersCount\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      transactionCount: {\n        serializedName: \"transactionsCount\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentError: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentError\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      error: {\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"TextAnalyticsError\"\n        }\n      }\n    }\n  }\n};\n\nexport const TextDocumentBatchStatistics: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TextDocumentBatchStatistics\",\n    modelProperties: {\n      documentCount: {\n        serializedName: \"documentsCount\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      validDocumentCount: {\n        serializedName: \"validDocumentsCount\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      erroneousDocumentCount: {\n        serializedName: \"erroneousDocumentsCount\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      transactionCount: {\n        serializedName: \"transactionsCount\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const PiiTaskResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"PiiTaskResult\",\n    modelProperties: {\n      results: {\n        serializedName: \"results\",\n        type: {\n          name: \"Composite\",\n          className: \"PiiResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const PiiResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"PiiResult\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"PiiDocumentEntities\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const PiiDocumentEntities: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"PiiDocumentEntities\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      redactedText: {\n        serializedName: \"redactedText\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      entities: {\n        serializedName: \"entities\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"Entity\"\n            }\n          }\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyPhraseTaskResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyPhraseTaskResult\",\n    modelProperties: {\n      results: {\n        serializedName: \"results\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyPhraseResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyPhraseResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyPhraseResult\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentKeyPhrases\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentKeyPhrases: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentKeyPhrases\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      keyPhrases: {\n        serializedName: \"keyPhrases\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const EntityLinkingTaskResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntityLinkingTaskResult\",\n    modelProperties: {\n      results: {\n        serializedName: \"results\",\n        type: {\n          name: \"Composite\",\n          className: \"EntityLinkingResult\"\n        }\n      }\n    }\n  }\n};\n\nexport const EntityLinkingResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"EntityLinkingResult\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentLinkedEntities\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentLinkedEntities: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentLinkedEntities\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      entities: {\n        serializedName: \"entities\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"LinkedEntity\"\n            }\n          }\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const LinkedEntity: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"LinkedEntity\",\n    modelProperties: {\n      name: {\n        serializedName: \"name\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      matches: {\n        serializedName: \"matches\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"Match\"\n            }\n          }\n        }\n      },\n      language: {\n        serializedName: \"language\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      dataSourceEntityId: {\n        serializedName: \"id\",\n        type: {\n          name: \"String\"\n        }\n      },\n      url: {\n        serializedName: \"url\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      dataSource: {\n        serializedName: \"dataSource\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      bingEntitySearchApiId: {\n        serializedName: \"bingId\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const Match: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Match\",\n    modelProperties: {\n      confidenceScore: {\n        serializedName: \"confidenceScore\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      offset: {\n        serializedName: \"offset\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      length: {\n        serializedName: \"length\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const SentimentTaskResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentimentTaskResult\",\n    modelProperties: {\n      results: {\n        serializedName: \"results\",\n        type: {\n          name: \"Composite\",\n          className: \"SentimentResponse\"\n        }\n      }\n    }\n  }\n};\n\nexport const SentimentResponse: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentimentResponse\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentSentiment\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentSentiment: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentSentiment\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      sentiment: {\n        serializedName: \"sentiment\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"positive\", \"neutral\", \"negative\", \"mixed\"]\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      },\n      confidenceScores: {\n        serializedName: \"confidenceScores\",\n        type: {\n          name: \"Composite\",\n          className: \"SentimentConfidenceScores\"\n        }\n      },\n      sentenceSentiments: {\n        serializedName: \"sentences\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SentenceSentiment\"\n            }\n          }\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const SentimentConfidenceScores: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentimentConfidenceScores\",\n    modelProperties: {\n      positive: {\n        serializedName: \"positive\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      neutral: {\n        serializedName: \"neutral\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      negative: {\n        serializedName: \"negative\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const SentenceSentiment: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentenceSentiment\",\n    modelProperties: {\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      sentiment: {\n        serializedName: \"sentiment\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"positive\", \"neutral\", \"negative\"]\n        }\n      },\n      confidenceScores: {\n        serializedName: \"confidenceScores\",\n        type: {\n          name: \"Composite\",\n          className: \"SentimentConfidenceScores\"\n        }\n      },\n      offset: {\n        serializedName: \"offset\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      length: {\n        serializedName: \"length\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      targets: {\n        serializedName: \"targets\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SentenceTarget\"\n            }\n          }\n        }\n      },\n      assessments: {\n        serializedName: \"assessments\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"SentenceAssessment\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const SentenceTarget: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentenceTarget\",\n    modelProperties: {\n      sentiment: {\n        serializedName: \"sentiment\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"positive\", \"mixed\", \"negative\"]\n        }\n      },\n      confidenceScores: {\n        serializedName: \"confidenceScores\",\n        type: {\n          name: \"Composite\",\n          className: \"TargetConfidenceScoreLabel\"\n        }\n      },\n      offset: {\n        serializedName: \"offset\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      length: {\n        serializedName: \"length\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      relations: {\n        serializedName: \"relations\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TargetRelation\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const TargetConfidenceScoreLabel: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TargetConfidenceScoreLabel\",\n    modelProperties: {\n      positive: {\n        serializedName: \"positive\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      negative: {\n        serializedName: \"negative\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const TargetRelation: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TargetRelation\",\n    modelProperties: {\n      relationType: {\n        serializedName: \"relationType\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"assessment\", \"target\"]\n        }\n      },\n      ref: {\n        serializedName: \"ref\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const SentenceAssessment: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"SentenceAssessment\",\n    modelProperties: {\n      sentiment: {\n        serializedName: \"sentiment\",\n        required: true,\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"positive\", \"mixed\", \"negative\"]\n        }\n      },\n      confidenceScores: {\n        serializedName: \"confidenceScores\",\n        type: {\n          name: \"Composite\",\n          className: \"TargetConfidenceScoreLabel\"\n        }\n      },\n      offset: {\n        serializedName: \"offset\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      length: {\n        serializedName: \"length\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      isNegated: {\n        serializedName: \"isNegated\",\n        required: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const AnalyzeJobErrorsAndStatistics: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeJobErrorsAndStatistics\",\n    modelProperties: {\n      errors: {\n        serializedName: \"errors\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const Pagination: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Pagination\",\n    modelProperties: {\n      nextLink: {\n        serializedName: \"@nextLink\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareTaskResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareTaskResult\",\n    modelProperties: {\n      results: {\n        serializedName: \"results\",\n        type: {\n          name: \"Composite\",\n          className: \"HealthcareResult\"\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsError\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareResult\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentHealthcareEntities\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentHealthcareEntities: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentHealthcareEntities\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      entities: {\n        serializedName: \"entities\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"HealthcareEntity\"\n            }\n          }\n        }\n      },\n      relations: {\n        serializedName: \"relations\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"HealthcareRelation\"\n            }\n          }\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareEntityProperties: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareEntityProperties\",\n    modelProperties: {\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      category: {\n        serializedName: \"category\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      subcategory: {\n        serializedName: \"subcategory\",\n        type: {\n          name: \"String\"\n        }\n      },\n      offset: {\n        serializedName: \"offset\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      length: {\n        serializedName: \"length\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      confidenceScore: {\n        serializedName: \"confidenceScore\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareLinkingProperties: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareLinkingProperties\",\n    modelProperties: {\n      assertion: {\n        serializedName: \"assertion\",\n        type: {\n          name: \"Composite\",\n          className: \"HealthcareAssertion\"\n        }\n      },\n      name: {\n        serializedName: \"name\",\n        type: {\n          name: \"String\"\n        }\n      },\n      links: {\n        serializedName: \"links\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"HealthcareEntityLink\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareAssertion: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareAssertion\",\n    modelProperties: {\n      conditionality: {\n        serializedName: \"conditionality\",\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"hypothetical\", \"conditional\"]\n        }\n      },\n      certainty: {\n        serializedName: \"certainty\",\n        type: {\n          name: \"Enum\",\n          allowedValues: [\n            \"positive\",\n            \"positivePossible\",\n            \"neutralPossible\",\n            \"negativePossible\",\n            \"negative\"\n          ]\n        }\n      },\n      association: {\n        serializedName: \"association\",\n        type: {\n          name: \"Enum\",\n          allowedValues: [\"subject\", \"other\"]\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareEntityLink: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareEntityLink\",\n    modelProperties: {\n      dataSource: {\n        serializedName: \"dataSource\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareRelation: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareRelation\",\n    modelProperties: {\n      relationType: {\n        serializedName: \"relationType\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      entities: {\n        serializedName: \"entities\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"HealthcareRelationEntity\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const HealthcareRelationEntity: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareRelationEntity\",\n    modelProperties: {\n      ref: {\n        serializedName: \"ref\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      role: {\n        serializedName: \"role\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const LanguageBatchInput: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"LanguageBatchInput\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DetectLanguageInput\"\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport const DetectLanguageInput: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DetectLanguageInput\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      text: {\n        serializedName: \"text\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      countryHint: {\n        serializedName: \"countryHint\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const LanguageResult: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"LanguageResult\",\n    modelProperties: {\n      documents: {\n        serializedName: \"documents\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentLanguage\"\n            }\n          }\n        }\n      },\n      errors: {\n        serializedName: \"errors\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DocumentError\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentBatchStatistics\"\n        }\n      },\n      modelVersion: {\n        serializedName: \"modelVersion\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DocumentLanguage: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DocumentLanguage\",\n    modelProperties: {\n      id: {\n        serializedName: \"id\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      detectedLanguage: {\n        serializedName: \"detectedLanguage\",\n        type: {\n          name: \"Composite\",\n          className: \"DetectedLanguage\"\n        }\n      },\n      warnings: {\n        serializedName: \"warnings\",\n        required: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"TextAnalyticsWarning\"\n            }\n          }\n        }\n      },\n      statistics: {\n        serializedName: \"statistics\",\n        type: {\n          name: \"Composite\",\n          className: \"TextDocumentStatistics\"\n        }\n      }\n    }\n  }\n};\n\nexport const DetectedLanguage: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DetectedLanguage\",\n    modelProperties: {\n      name: {\n        serializedName: \"name\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      iso6391Name: {\n        serializedName: \"iso6391Name\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      confidenceScore: {\n        serializedName: \"confidenceScore\",\n        required: true,\n        type: {\n          name: \"Number\"\n        }\n      }\n    }\n  }\n};\n\nexport const AnalyzeBatchInput: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeBatchInput\",\n    modelProperties: {\n      ...JobDescriptor.type.modelProperties,\n      ...AnalysisInput.type.modelProperties,\n      ...JobManifest.type.modelProperties\n    }\n  }\n};\n\nexport const AnalyzeJobMetadata: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeJobMetadata\",\n    modelProperties: {\n      ...JobMetadata.type.modelProperties,\n      ...AnalyzeJobDisplayName.type.modelProperties\n    }\n  }\n};\n\nexport const HealthcareJobState: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareJobState\",\n    modelProperties: {\n      ...JobMetadata.type.modelProperties,\n      ...HealthcareTaskResult.type.modelProperties,\n      ...Pagination.type.modelProperties\n    }\n  }\n};\n\nexport const AnalyzeJobState: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"AnalyzeJobState\",\n    modelProperties: {\n      ...AnalyzeJobMetadata.type.modelProperties,\n      ...TasksState.type.modelProperties,\n      ...AnalyzeJobErrorsAndStatistics.type.modelProperties,\n      ...Pagination.type.modelProperties\n    }\n  }\n};\n\nexport const TasksStateTasksEntityRecognitionTasksItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksStateTasksEntityRecognitionTasksItem\",\n    modelProperties: {\n      ...TaskState.type.modelProperties,\n      ...EntitiesTaskResult.type.modelProperties\n    }\n  }\n};\n\nexport const TasksStateTasksEntityRecognitionPiiTasksItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksStateTasksEntityRecognitionPiiTasksItem\",\n    modelProperties: {\n      ...TaskState.type.modelProperties,\n      ...PiiTaskResult.type.modelProperties\n    }\n  }\n};\n\nexport const TasksStateTasksKeyPhraseExtractionTasksItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksStateTasksKeyPhraseExtractionTasksItem\",\n    modelProperties: {\n      ...TaskState.type.modelProperties,\n      ...KeyPhraseTaskResult.type.modelProperties\n    }\n  }\n};\n\nexport const TasksStateTasksEntityLinkingTasksItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksStateTasksEntityLinkingTasksItem\",\n    modelProperties: {\n      ...TaskState.type.modelProperties,\n      ...EntityLinkingTaskResult.type.modelProperties\n    }\n  }\n};\n\nexport const TasksStateTasksSentimentAnalysisTasksItem: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"TasksStateTasksSentimentAnalysisTasksItem\",\n    modelProperties: {\n      ...TaskState.type.modelProperties,\n      ...SentimentTaskResult.type.modelProperties\n    }\n  }\n};\n\nexport const HealthcareEntity: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"HealthcareEntity\",\n    modelProperties: {\n      ...HealthcareEntityProperties.type.modelProperties,\n      ...HealthcareLinkingProperties.type.modelProperties\n    }\n  }\n};\n\nexport const GeneratedClientAnalyzeHeaders: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientAnalyzeHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientCancelHealthJobHeaders: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientCancelHealthJobHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const GeneratedClientHealthHeaders: coreClient.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"GeneratedClientHealthHeaders\",\n    modelProperties: {\n      operationLocation: {\n        serializedName: \"operation-location\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n", "/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport {\n  OperationParameter,\n  OperationURLParameter,\n  OperationQueryParameter\n} from \"@azure/core-client\";\nimport {\n  AnalyzeBatchInput as AnalyzeBatchInputMapper,\n  MultiLanguageBatchInput as MultiLanguageBatchInputMapper,\n  LanguageBatchInput as LanguageBatchInputMapper\n} from \"../models/mappers\";\n\nexport const contentType: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Content-Type\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const body: OperationParameter = {\n  parameterPath: [\"options\", \"body\"],\n  mapper: AnalyzeBatchInputMapper\n};\n\nexport const accept: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json, text/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const endpoint: OperationURLParameter = {\n  parameterPath: \"endpoint\",\n  mapper: {\n    serializedName: \"Endpoint\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n\nexport const apiVersion: OperationURLParameter = {\n  parameterPath: \"apiVersion\",\n  mapper: {\n    defaultValue: \"v3.1\",\n    isConstant: true,\n    serializedName: \"ApiVersion\",\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n\nexport const jobId: OperationURLParameter = {\n  parameterPath: \"jobId\",\n  mapper: {\n    serializedName: \"jobId\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const includeStatistics: OperationQueryParameter = {\n  parameterPath: [\"options\", \"includeStatistics\"],\n  mapper: {\n    serializedName: \"showStats\",\n    type: {\n      name: \"Boolean\"\n    }\n  }\n};\n\nexport const top: OperationQueryParameter = {\n  parameterPath: [\"options\", \"top\"],\n  mapper: {\n    defaultValue: 20,\n    constraints: {\n      InclusiveMaximum: 50,\n      InclusiveMinimum: 1\n    },\n    serializedName: \"$top\",\n    type: {\n      name: \"Number\"\n    }\n  }\n};\n\nexport const skip: OperationQueryParameter = {\n  parameterPath: [\"options\", \"skip\"],\n  mapper: {\n    constraints: {\n      InclusiveMinimum: 0\n    },\n    serializedName: \"$skip\",\n    type: {\n      name: \"Number\"\n    }\n  }\n};\n\nexport const jobId1: OperationURLParameter = {\n  parameterPath: \"jobId\",\n  mapper: {\n    serializedName: \"jobId\",\n    required: true,\n    type: {\n      name: \"Uuid\"\n    }\n  }\n};\n\nexport const input: OperationParameter = {\n  parameterPath: \"input\",\n  mapper: MultiLanguageBatchInputMapper\n};\n\nexport const modelVersion: OperationQueryParameter = {\n  parameterPath: [\"options\", \"modelVersion\"],\n  mapper: {\n    serializedName: \"model-version\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const stringIndexType: OperationQueryParameter = {\n  parameterPath: [\"options\", \"stringIndexType\"],\n  mapper: {\n    serializedName: \"stringIndexType\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const loggingOptOut: OperationQueryParameter = {\n  parameterPath: [\"options\", \"loggingOptOut\"],\n  mapper: {\n    serializedName: \"loggingOptOut\",\n    type: {\n      name: \"Boolean\"\n    }\n  }\n};\n\nexport const domain: OperationQueryParameter = {\n  parameterPath: [\"options\", \"domain\"],\n  mapper: {\n    serializedName: \"domain\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const piiCategories: OperationQueryParameter = {\n  parameterPath: [\"options\", \"piiCategories\"],\n  mapper: {\n    constraints: {\n      UniqueItems: true\n    },\n    serializedName: \"piiCategories\",\n    type: {\n      name: \"Sequence\",\n      element: {\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  },\n  collectionFormat: \"CSV\"\n};\n\nexport const input1: OperationParameter = {\n  parameterPath: \"input\",\n  mapper: LanguageBatchInputMapper\n};\n\nexport const opinionMining: OperationQueryParameter = {\n  parameterPath: [\"options\", \"opinionMining\"],\n  mapper: {\n    serializedName: \"opinionMining\",\n    type: {\n      name: \"Boolean\"\n    }\n  }\n};\n", "/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreClient from \"@azure/core-client\";\nimport { GeneratedClientOptionalParams } from \"./models\";\n\n/** @internal */\nexport class GeneratedClientContext extends coreClient.ServiceClient {\n  endpoint: string;\n  apiVersion: string;\n\n  /**\n   * Initializes a new instance of the GeneratedClientContext class.\n   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:\n   *                 https://westus.api.cognitive.microsoft.com).\n   * @param options The parameter options\n   */\n  constructor(endpoint: string, options?: GeneratedClientOptionalParams) {\n    if (endpoint === undefined) {\n      throw new Error(\"'endpoint' cannot be null\");\n    }\n\n    // Initializing default values for options\n    if (!options) {\n      options = {};\n    }\n    const defaults: GeneratedClientOptionalParams = {\n      requestContentType: \"application/json; charset=utf-8\"\n    };\n\n    const packageDetails = `azsdk-js-ai-text-analytics/5.1.0`;\n    const userAgentPrefix =\n      options.userAgentOptions && options.userAgentOptions.userAgentPrefix\n        ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n        : `${packageDetails}`;\n\n    const optionsWithDefaults = {\n      ...defaults,\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri: options.endpoint || \"{Endpoint}/text/analytics/{ApiVersion}\"\n    };\n    super(optionsWithDefaults);\n    // Parameter assignments\n    this.endpoint = endpoint;\n\n    // Assigning values to Constant parameters\n    this.apiVersion = options.apiVersion || \"v3.1\";\n  }\n}\n", "/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreClient from \"@azure/core-client\";\nimport * as Parameters from \"./models/parameters\";\nimport * as Mappers from \"./models/mappers\";\nimport { GeneratedClientContext } from \"./generatedClientContext\";\nimport {\n  GeneratedClientOptionalParams,\n  GeneratedClientAnalyzeOptionalParams,\n  GeneratedClientAnalyzeResponse,\n  GeneratedClientAnalyzeStatusOptionalParams,\n  GeneratedClientAnalyzeStatusResponse,\n  GeneratedClientHealthStatusOptionalParams,\n  GeneratedClientHealthStatusResponse,\n  GeneratedClientCancelHealthJobOptionalParams,\n  GeneratedClientCancelHealthJobResponse,\n  MultiLanguageBatchInput,\n  GeneratedClientHealthOptionalParams,\n  GeneratedClientHealthResponse,\n  GeneratedClientEntitiesRecognitionGeneralOptionalParams,\n  GeneratedClientEntitiesRecognitionGeneralResponse,\n  GeneratedClientEntitiesRecognitionPiiOptionalParams,\n  GeneratedClientEntitiesRecognitionPiiResponse,\n  GeneratedClientEntitiesLinkingOptionalParams,\n  GeneratedClientEntitiesLinkingResponse,\n  GeneratedClientKeyPhrasesOptionalParams,\n  GeneratedClientKeyPhrasesResponse,\n  LanguageBatchInput,\n  GeneratedClientLanguagesOptionalParams,\n  GeneratedClientLanguagesResponse,\n  GeneratedClientSentimentOptionalParams,\n  GeneratedClientSentimentResponse\n} from \"./models\";\n\n/** @internal */\nexport class GeneratedClient extends GeneratedClientContext {\n  /**\n   * Initializes a new instance of the GeneratedClient class.\n   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:\n   *                 https://westus.api.cognitive.microsoft.com).\n   * @param options The parameter options\n   */\n  constructor(endpoint: string, options?: GeneratedClientOptionalParams) {\n    super(endpoint, options);\n  }\n\n  /**\n   * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.\n   * @param options The options parameters.\n   */\n  analyze(\n    options?: GeneratedClientAnalyzeOptionalParams\n  ): Promise<GeneratedClientAnalyzeResponse> {\n    return this.sendOperationRequest({ options }, analyzeOperationSpec);\n  }\n\n  /**\n   * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are\n   * completed, the job will transition to the completed state and results will be available for each\n   * task.\n   * @param jobId Job ID for Analyze\n   * @param options The options parameters.\n   */\n  analyzeStatus(\n    jobId: string,\n    options?: GeneratedClientAnalyzeStatusOptionalParams\n  ): Promise<GeneratedClientAnalyzeStatusResponse> {\n    return this.sendOperationRequest(\n      { jobId, options },\n      analyzeStatusOperationSpec\n    );\n  }\n\n  /**\n   * Get details of the healthcare prediction job specified by the jobId.\n   * @param jobId Job ID\n   * @param options The options parameters.\n   */\n  healthStatus(\n    jobId: string,\n    options?: GeneratedClientHealthStatusOptionalParams\n  ): Promise<GeneratedClientHealthStatusResponse> {\n    return this.sendOperationRequest(\n      { jobId, options },\n      healthStatusOperationSpec\n    );\n  }\n\n  /**\n   * Cancel healthcare prediction job.\n   * @param jobId Job ID\n   * @param options The options parameters.\n   */\n  cancelHealthJob(\n    jobId: string,\n    options?: GeneratedClientCancelHealthJobOptionalParams\n  ): Promise<GeneratedClientCancelHealthJobResponse> {\n    return this.sendOperationRequest(\n      { jobId, options },\n      cancelHealthJobOperationSpec\n    );\n  }\n\n  /**\n   * Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions,\n   * symptoms, etc) and their relations.\n   * @param input Collection of documents to analyze.\n   * @param options The options parameters.\n   */\n  health(\n    input: MultiLanguageBatchInput,\n    options?: GeneratedClientHealthOptionalParams\n  ): Promise<GeneratedClientHealthResponse> {\n    return this.sendOperationRequest({ input, options }, healthOperationSpec);\n  }\n\n  /**\n   * The API returns a list of general named entities in a given document. For the list of supported\n   * entity types, check <a href=\"https://aka.ms/taner\">Supported Entity Types in Text Analytics API</a>.\n   * See the <a href=\"https://aka.ms/talangs\">Supported languages in Text Analytics API</a> for the list\n   * of enabled languages.\n   * @param input Collection of documents to analyze.\n   * @param options The options parameters.\n   */\n  entitiesRecognitionGeneral(\n    input: MultiLanguageBatchInput,\n    options?: GeneratedClientEntitiesRecognitionGeneralOptionalParams\n  ): Promise<GeneratedClientEntitiesRecognitionGeneralResponse> {\n    return this.sendOperationRequest(\n      { input, options },\n      entitiesRecognitionGeneralOperationSpec\n    );\n  }\n\n  /**\n   * The API returns a list of entities with personal information (\\\"SSN\\\", \\\"Bank Account\\\" etc) in the\n   * document. For the list of supported entity types, check <a href=\"https://aka.ms/tanerpii\">Supported\n   * Entity Types in Text Analytics API</a>. See the <a href=\"https://aka.ms/talangs\">Supported languages\n   * in Text Analytics API</a> for the list of enabled languages.\n   *\n   * @param input Collection of documents to analyze.\n   * @param options The options parameters.\n   */\n  entitiesRecognitionPii(\n    input: MultiLanguageBatchInput,\n    options?: GeneratedClientEntitiesRecognitionPiiOptionalParams\n  ): Promise<GeneratedClientEntitiesRecognitionPiiResponse> {\n    return this.sendOperationRequest(\n      { input, options },\n      entitiesRecognitionPiiOperationSpec\n    );\n  }\n\n  /**\n   * The API returns a list of recognized entities with links to a well known knowledge base. See the <a\n   * href=\"https://aka.ms/talangs\">Supported languages in Text Analytics API</a> for the list of enabled\n   * languages.\n   * @param input Collection of documents to analyze.\n   * @param options The options parameters.\n   */\n  entitiesLinking(\n    input: MultiLanguageBatchInput,\n    options?: GeneratedClientEntitiesLinkingOptionalParams\n  ): Promise<GeneratedClientEntitiesLinkingResponse> {\n    return this.sendOperationRequest(\n      { input, options },\n      entitiesLinkingOperationSpec\n    );\n  }\n\n  /**\n   * The API returns a list of strings denoting the key phrases in the input text. See the <a\n   * href=\"https://aka.ms/talangs\">Supported languages in Text Analytics API</a> for the list of enabled\n   * languages.\n   * @param input Collection of documents to analyze.\n   * @param options The options parameters.\n   */\n  keyPhrases(\n    input: MultiLanguageBatchInput,\n    options?: GeneratedClientKeyPhrasesOptionalParams\n  ): Promise<GeneratedClientKeyPhrasesResponse> {\n    return this.sendOperationRequest(\n      { input, options },\n      keyPhrasesOperationSpec\n    );\n  }\n\n  /**\n   * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1\n   * indicate 100% certainty that the identified language is true. See the <a\n   * href=\"https://aka.ms/talangs\">Supported languages in Text Analytics API</a> for the list of enabled\n   * languages.\n   * @param input Collection of documents to analyze for language endpoint.\n   * @param options The options parameters.\n   */\n  languages(\n    input: LanguageBatchInput,\n    options?: GeneratedClientLanguagesOptionalParams\n  ): Promise<GeneratedClientLanguagesResponse> {\n    return this.sendOperationRequest(\n      { input, options },\n      languagesOperationSpec\n    );\n  }\n\n  /**\n   * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple\n   * levels of granularity, start from the a document level, down to sentence and key terms (targets and\n   * assessments).\n   * @param input Collection of documents to analyze.\n   * @param options The options parameters.\n   */\n  sentiment(\n    input: MultiLanguageBatchInput,\n    options?: GeneratedClientSentimentOptionalParams\n  ): Promise<GeneratedClientSentimentResponse> {\n    return this.sendOperationRequest(\n      { input, options },\n      sentimentOperationSpec\n    );\n  }\n}\n// Operation Specifications\nconst serializer = coreClient.createSerializer(Mappers, /* isXml */ false);\n\nconst analyzeOperationSpec: coreClient.OperationSpec = {\n  path: \"/analyze\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientAnalyzeHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.body,\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst analyzeStatusOperationSpec: coreClient.OperationSpec = {\n  path: \"/analyze/jobs/{jobId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.AnalyzeJobState\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.top,\n    Parameters.skip\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion, Parameters.jobId],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst healthStatusOperationSpec: coreClient.OperationSpec = {\n  path: \"/entities/health/jobs/{jobId}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.HealthcareJobState\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.top,\n    Parameters.skip\n  ],\n  urlParameters: [\n    Parameters.endpoint,\n    Parameters.apiVersion,\n    Parameters.jobId1\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst cancelHealthJobOperationSpec: coreClient.OperationSpec = {\n  path: \"/entities/health/jobs/{jobId}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientCancelHealthJobHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  urlParameters: [\n    Parameters.endpoint,\n    Parameters.apiVersion,\n    Parameters.jobId1\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst healthOperationSpec: coreClient.OperationSpec = {\n  path: \"/entities/health/jobs\",\n  httpMethod: \"POST\",\n  responses: {\n    202: {\n      headersMapper: Mappers.GeneratedClientHealthHeaders\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input,\n  queryParameters: [\n    Parameters.modelVersion,\n    Parameters.stringIndexType,\n    Parameters.loggingOptOut\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst entitiesRecognitionGeneralOperationSpec: coreClient.OperationSpec = {\n  path: \"/entities/recognition/general\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.EntitiesResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input,\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.modelVersion,\n    Parameters.stringIndexType,\n    Parameters.loggingOptOut\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst entitiesRecognitionPiiOperationSpec: coreClient.OperationSpec = {\n  path: \"/entities/recognition/pii\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.PiiResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input,\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.modelVersion,\n    Parameters.stringIndexType,\n    Parameters.loggingOptOut,\n    Parameters.domain,\n    Parameters.piiCategories\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst entitiesLinkingOperationSpec: coreClient.OperationSpec = {\n  path: \"/entities/linking\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.EntityLinkingResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input,\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.modelVersion,\n    Parameters.stringIndexType,\n    Parameters.loggingOptOut\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst keyPhrasesOperationSpec: coreClient.OperationSpec = {\n  path: \"/keyPhrases\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyPhraseResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input,\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.modelVersion,\n    Parameters.loggingOptOut\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst languagesOperationSpec: coreClient.OperationSpec = {\n  path: \"/languages\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.LanguageResult\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input1,\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.modelVersion,\n    Parameters.loggingOptOut\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst sentimentOperationSpec: coreClient.OperationSpec = {\n  path: \"/sentiment\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.SentimentResponse\n    },\n    default: {\n      bodyMapper: Mappers.ErrorResponse\n    }\n  },\n  requestBody: Parameters.input,\n  queryParameters: [\n    Parameters.includeStatistics,\n    Parameters.modelVersion,\n    Parameters.stringIndexType,\n    Parameters.loggingOptOut,\n    Parameters.opinionMining\n  ],\n  urlParameters: [Parameters.endpoint, Parameters.apiVersion],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The `@azure/logger` configuration for this package.\n * @internal\n */\nexport const logger = createClientLogger(\"ai-text-analytics\");\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nconst url = URL;\nconst urlSearchParams = URLSearchParams;\n\nexport { url as URL, urlSearchParams as URLSearchParams };\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { URL, URLSearchParams } from \"./utils/url\";\nimport { logger } from \"./logger\";\nimport { StringIndexType as GeneratedStringIndexType } from \"./generated\";\nimport { TextAnalyticsAction } from \"./textAnalyticsAction\";\n\n/**\n * @internal\n */\nexport interface IdObject {\n  id: string;\n}\n\n/**\n * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,\n * return a sorted array of results.\n *\n * @internal\n * @param sortedArray - An array of entries sorted by `id`\n * @param unsortedArray - An array of entries that contain `id` but are not sorted\n */\nexport function sortResponseIdObjects<T extends IdObject, U extends IdObject>(\n  sortedArray: T[],\n  unsortedArray: U[]\n): U[] {\n  const unsortedMap = new Map<string, U>();\n  for (const item of unsortedArray) {\n    unsortedMap.set(item.id, item);\n  }\n\n  if (unsortedArray.length !== sortedArray.length) {\n    const ordinal = unsortedArray.length > sortedArray.length ? \"more\" : \"fewer\";\n    logger.warning(\n      `The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`\n    );\n  }\n\n  const result: U[] = [];\n  for (const sortedItem of sortedArray) {\n    const item = unsortedMap.get(sortedItem.id);\n    if (item) {\n      result.push(item);\n    }\n  }\n  return result;\n}\n\n/**\n * @internal\n */\nexport interface AssessmentIndex {\n  document: number;\n  sentence: number;\n  assessment: number;\n}\n\n/**\n * @internal\n */\nexport function parseAssessmentIndex(pointer: string): AssessmentIndex {\n  const regex = new RegExp(/#\\/documents\\/(\\d+)\\/sentences\\/(\\d+)\\/assessments\\/(\\d+)/);\n  const res = regex.exec(pointer);\n  if (res !== null) {\n    const assessmentIndex: AssessmentIndex = {\n      document: parseInt(res[1]),\n      sentence: parseInt(res[2]),\n      assessment: parseInt(res[3])\n    };\n    return assessmentIndex;\n  } else {\n    throw new Error(`Pointer \"${pointer}\" is not a valid Assessment pointer`);\n  }\n}\n\n/**\n * Parses the index of the healthcare entity from a JSON pointer.\n * @param pointer - a JSON pointer representing an entity\n * @internal\n */\nexport function parseHealthcareEntityIndex(pointer: string): number {\n  const regex = new RegExp(/#\\/results\\/documents\\/(\\d+)\\/entities\\/(\\d+)/);\n  const res = regex.exec(pointer);\n  if (res !== null) {\n    return parseInt(res[2]);\n  } else {\n    throw new Error(`Pointer \"${pointer}\" is not a valid healthcare entity pointer`);\n  }\n}\n\nconst jsEncodingUnit = \"Utf16CodeUnit\";\n\n/**\n * Measurement units that can used to calculate the offset and length properties.\n */\nexport type StringIndexType = \"TextElement_v8\" | \"UnicodeCodePoint\" | \"Utf16CodeUnit\";\n\n/**\n * @internal\n */\nexport function addStrEncodingParam<Options extends { stringIndexType?: StringIndexType }>(\n  options: Options\n): Options & { stringIndexType: StringIndexType } {\n  return { ...options, stringIndexType: options.stringIndexType || jsEncodingUnit };\n}\n\n/**\n * Set the stringIndexType property with default if it does not exist in x.\n * @param options - operation options bag that has a {@link StringIndexType}\n * @internal\n */\nexport function setStrEncodingParam<X extends { stringIndexType?: GeneratedStringIndexType }>(\n  x: X\n): X & { stringIndexType: GeneratedStringIndexType } {\n  return { ...x, stringIndexType: x.stringIndexType || jsEncodingUnit };\n}\n\nexport function setStrEncodingParamValue(\n  stringIndexType?: GeneratedStringIndexType\n): GeneratedStringIndexType {\n  return stringIndexType || jsEncodingUnit;\n}\n\n/**\n * Set the opinion mining property\n * @internal\n */\nexport function setOpinionMining<X extends { includeOpinionMining?: boolean }>(\n  x: X\n): X & { opinionMining?: boolean } {\n  return { ...x, opinionMining: x.includeOpinionMining };\n}\n\n/**\n * Set the pii categories property\n * @internal\n */\nexport function setCategoriesFilter<X extends { categoriesFilter?: string[] }>(\n  x: X\n): X & { piiCategories?: string[] } {\n  return { ...x, piiCategories: x.categoriesFilter };\n}\n\n/**\n * @internal\n */\nexport function addParamsToTask<X extends TextAnalyticsAction>(\n  action: X\n): { parameters?: Omit<X, \"actionName\">; taskName?: string } {\n  const { actionName, ...params } = action;\n  return { parameters: params, taskName: actionName };\n}\n\n/**\n * Set the modelVersion property with default if it does not exist in x.\n * @param options - operation options bag that has a {@link StringIndexType}\n * @internal\n */\nexport function setModelVersionParam<X extends { modelVersion?: string }>(\n  x: X\n): X & { modelVersion: string } {\n  return { ...x, modelVersion: x.modelVersion || \"latest\" };\n}\n\n/**\n * @internal\n */\nexport interface PageParam {\n  top: number;\n  skip: number;\n}\n\n/**\n * @internal\n */\nexport function nextLinkToTopAndSkip(nextLink: string): PageParam {\n  const url = new URL(nextLink);\n  const searchParams = new URLSearchParams(url.searchParams);\n  let top: number;\n  if (searchParams.has(\"$top\")) {\n    top = parseInt(searchParams.get(\"$top\")!);\n  } else {\n    throw new Error(`nextLink URL does not have the $top param: ${nextLink}`);\n  }\n  let skip: number;\n  if (searchParams.has(\"$skip\")) {\n    skip = parseInt(searchParams.get(\"$skip\")!);\n  } else {\n    throw new Error(`nextLink URL does not have the $skip param: ${nextLink}`);\n  }\n  return {\n    skip: skip,\n    top: top\n  };\n}\n\n/**\n * @internal\n */\nexport function getOperationId(operationLocation: string): string {\n  const lastSlashIndex = operationLocation.lastIndexOf(\"/\");\n  return operationLocation.substring(lastSlashIndex + 1);\n}\n\n/**\n * @internal\n * parses incoming errors from the service and if the inner error code is\n * InvalidDocumentBatch, it exposes that as the statusCode instead.\n * @param error - the incoming error\n */\nexport function handleInvalidDocumentBatch(error: unknown): any {\n  const castError = error as {\n    response: {\n      parsedBody?: {\n        error?: {\n          innererror?: {\n            code: string;\n            message: string;\n          };\n        };\n      };\n    };\n    statusCode: number;\n  };\n  const innerCode = castError.response?.parsedBody?.error?.innererror?.code;\n  const innerMessage = castError.response?.parsedBody?.error?.innererror?.message;\n  if (innerMessage) {\n    return innerCode === \"InvalidDocumentBatch\"\n      ? new RestError(innerMessage, { code: innerCode, statusCode: castError.statusCode })\n      : error;\n  } else {\n    // unfortunately, the service currently does not follow the swagger definition\n    // for errors in some cases.\n    // Issue: https://msazure.visualstudio.com/Cognitive%20Services/_workitems/edit/8775003/?workitem=8972164\n    // throw new Error(\n    //   `The error coming from the service does not follow the expected structure: ${error}`\n    // );\n    logger.warning(\n      `The error coming from the service does not follow the expected structure: ${error}`\n    );\n    return error;\n  }\n}\n\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @internal\n * @param timeInMs - The number of milliseconds to be delayed.\n * @returns Resolved promise\n */\nexport function delay(timeInMs: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));\n}\n\n/**\n * @internal\n */\nexport function compose<T1, T2, T3>(fn1: (x: T1) => T2, fn2: (y: T2) => T3): (x: T1) => T3 {\n  return (value: T1) => fn2(fn1(value));\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TextDocumentStatistics,\n  TextAnalyticsError as GeneratedTextAnalyticsErrorModel,\n  InnerError,\n  ErrorCodeValue,\n  InnerErrorCodeValue,\n  TextAnalyticsWarning,\n  DocumentError,\n  TextDocumentBatchStatistics,\n  TextDocumentInput\n} from \"./generated/models\";\nimport { sortResponseIdObjects } from \"./util\";\n\n/**\n * The result of a text analytics operation on a single input document.\n * @internal\n */\nexport type TextAnalyticsResult = TextAnalyticsSuccessResult | TextAnalyticsErrorResult;\n\n/**\n * An Error Code returned from the Text Analytics service. Possible\n * values include:\n *\n * For more information about the error, see the `message` property of the associated error.\n */\nexport type ErrorCode = ErrorCodeValue | InnerErrorCodeValue;\n\n/**\n * Type describing an error from the Text Analytics service.\n */\nexport interface TextAnalyticsError {\n  /**\n   * A code describing the kind of error produced\n   */\n  readonly code: ErrorCode;\n  /**\n   * A message from the service explaining the error\n   */\n  readonly message: string;\n  /**\n   * The target of the particular error (for example, the name of an invalid parameter)\n   */\n  readonly target?: string;\n}\n\n/**\n * Base type for results of text analytics operations corresponding to a single\n * input document.\n */\nexport interface TextAnalyticsSuccessResult {\n  /**\n   * Unique, non-empty document identifier.\n   */\n  readonly id: string;\n\n  /**\n   * Statistics about the input document and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  readonly statistics?: TextDocumentStatistics;\n\n  /**\n   * An array of warning data corresponding to this document.\n   *\n   * If no warnings were returned, this array will be empty.\n   */\n  readonly warnings: TextAnalyticsWarning[];\n\n  /**\n   * Discriminant to determine if that this is an error result.\n   */\n  readonly error?: undefined;\n}\n\n/**\n * Base type for error results of text analytics operations corresponding to a\n * single document.\n */\nexport interface TextAnalyticsErrorResult {\n  /**\n   * Unique, non-empty document identifier.\n   */\n  readonly id: string;\n\n  /**\n   * The Error for this document result.\n   */\n  readonly error: TextAnalyticsError;\n}\n\n/**\n * @internal\n */\nexport interface TextAnalyticsResultArray<T1 extends TextAnalyticsSuccessResult>\n  extends Array<T1 | TextAnalyticsErrorResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport interface TextAnalyticsResponse<T1 extends TextAnalyticsSuccessResult> {\n  /**\n   * Response by document\n   */\n  documents: T1[];\n  /**\n   * Errors by document id.\n   */\n  errors: DocumentError[];\n  /**\n   * if includeStatistics=true was specified in the request this field will contain information about the request payload.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * This field indicates which model is used for scoring.\n   */\n  modelVersion: string;\n}\n\n/**\n * Helper function for converting nested service error into\n * the unified TextAnalyticsError\n * @internal\n */\nexport function intoTextAnalyticsError(\n  errorModel: GeneratedTextAnalyticsErrorModel | InnerError\n): TextAnalyticsError {\n  // Return the deepest error. This will always be at most\n  // one level for TextAnalytics\n  if (errorModel.innererror !== undefined) {\n    return intoTextAnalyticsError(errorModel.innererror);\n  }\n\n  return {\n    code: errorModel.code,\n    message: errorModel.message,\n    target: errorModel.target\n  };\n}\n\n/**\n * @internal\n */\nexport function makeTextAnalyticsSuccessResult(\n  id: string,\n  warnings: TextAnalyticsWarning[],\n  statistics?: TextDocumentStatistics\n): TextAnalyticsSuccessResult {\n  return {\n    id,\n    statistics,\n    warnings\n  };\n}\n\n/**\n * @internal\n */\nexport function makeTextAnalyticsErrorResult(\n  id: string,\n  error: GeneratedTextAnalyticsErrorModel\n): TextAnalyticsErrorResult {\n  return {\n    id,\n    error: intoTextAnalyticsError(error)\n  };\n}\n\n/**\n * @internal\n * combines successful and erroneous results into a single array of results and\n * sort them so that the IDs order match that of the input documents array.\n * @param input - the array of documents sent to the service for processing.\n * @param response - the response received from the service.\n */\nexport function combineSuccessfulAndErroneousDocuments<TSuccess extends TextAnalyticsSuccessResult>(\n  input: TextDocumentInput[],\n  response: TextAnalyticsResponse<TSuccess>\n): (TSuccess | TextAnalyticsErrorResult)[] {\n  return processAndCombineSuccessfulAndErroneousDocuments(\n    input,\n    response,\n    (x) => x,\n    makeTextAnalyticsErrorResult\n  );\n}\n\n/**\n * @internal\n * combines successful and erroneous results into a single array of results and\n * sort them so that the IDs order match that of the input documents array.\n * @param input - the array of documents sent to the service for processing.\n * @param response - the response received from the service.\n * @param process - a function to convert the results from one type to another.\n */\nexport function processAndCombineSuccessfulAndErroneousDocuments<\n  TSuccessService extends TextAnalyticsSuccessResult,\n  TSuccessSDK extends TextAnalyticsSuccessResult,\n  TError extends TextAnalyticsErrorResult\n>(\n  input: TextDocumentInput[],\n  response: TextAnalyticsResponse<TSuccessService>,\n  processSuccess: (successResult: TSuccessService) => TSuccessSDK,\n  processError: (id: string, error: GeneratedTextAnalyticsErrorModel) => TError\n): (TSuccessSDK | TextAnalyticsErrorResult)[] {\n  const successResults: (TSuccessSDK | TextAnalyticsErrorResult)[] = response.documents.map(\n    processSuccess\n  );\n  const unsortedResults = successResults.concat(\n    response.errors.map((error) => processError(error.id, error.error))\n  );\n\n  return sortResponseIdObjects(input, unsortedResults);\n}\n\n/**\n * @internal\n * combines successful and erroneous results into a single array of results and\n * sort them so that the IDs order match that of the input documents array. It\n * also attaches statistics and modelVersion to the returned array.\n * @param input - the array of documents sent to the service for processing.\n * @param response - the response received from the service.\n */\nexport function combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion<\n  TSuccessService extends TextAnalyticsSuccessResult,\n  TSuccessSDK extends TextAnalyticsSuccessResult,\n  TError extends TextAnalyticsErrorResult\n>(\n  input: TextDocumentInput[],\n  response: TextAnalyticsResponse<TSuccessService>,\n  processSuccess: (doc: TSuccessService) => TSuccessSDK,\n  processError: (id: string, error: GeneratedTextAnalyticsErrorModel) => TError\n): TextAnalyticsResultArray<TSuccessSDK> {\n  const sorted = processAndCombineSuccessfulAndErroneousDocuments(\n    input,\n    response,\n    processSuccess,\n    processError\n  );\n  return Object.assign(sorted, {\n    statistics: response.statistics,\n    modelVersion: response.modelVersion\n  });\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport { DetectedLanguage, TextAnalyticsError, DocumentLanguage } from \"./generated/models\";\n\n/**\n * The result of the detect language operation on a single document.\n */\nexport type DetectLanguageResult = DetectLanguageSuccessResult | DetectLanguageErrorResult;\n\n/**\n * The result of the detect language operation on a single document,\n * containing a prediction of what language the document is written in.\n */\nexport interface DetectLanguageSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * The top detected language by confidence score.\n   */\n  readonly primaryLanguage: DetectedLanguage;\n}\n\n/**\n * An error result from the detect languge operation on a single document.\n */\nexport type DetectLanguageErrorResult = TextAnalyticsErrorResult;\n\n/**\n * @internal\n */\nexport function makeDetectLanguageResult(response: DocumentLanguage): DetectLanguageSuccessResult {\n  const { id, warnings, statistics, detectedLanguage } = response;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    primaryLanguage: detectedLanguage\n  };\n}\n\n/**\n * @internal\n */\nexport function makeDetectLanguageErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): DetectLanguageErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TextDocumentBatchStatistics, LanguageResult, TextDocumentInput } from \"./generated/models\";\nimport {\n  DetectLanguageResult,\n  makeDetectLanguageResult,\n  makeDetectLanguageErrorResult\n} from \"./detectLanguageResult\";\nimport { combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion } from \"./textAnalyticsResult\";\n\n/**\n * Array of `DetectLanguageResult` objects corresponding to a batch of input documents, and\n * annotated with information about the batch operation.\n */\nexport interface DetectLanguageResultArray extends Array<DetectLanguageResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport function makeDetectLanguageResultArray(\n  input: TextDocumentInput[],\n  response: LanguageResult\n): DetectLanguageResultArray {\n  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(\n    input,\n    response,\n    makeDetectLanguageResult,\n    makeDetectLanguageErrorResult\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport { Entity, TextAnalyticsError, DocumentEntities } from \"./generated/models\";\n\n/**\n * An entity from text analysis with information about its categorical\n * classification.\n */\nexport interface CategorizedEntity extends Entity {}\n\n/**\n * The result of the recognize entities operation on a single document.\n */\nexport type RecognizeCategorizedEntitiesResult =\n  | RecognizeCategorizedEntitiesSuccessResult\n  | RecognizeCategorizedEntitiesErrorResult;\n\n/**\n * The result of the recognize entities operation on a single document, containing the collection of\n * `Entity` objects identified in that document.\n */\nexport interface RecognizeCategorizedEntitiesSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * The collection of entities identified in the input document.\n   */\n  readonly entities: CategorizedEntity[];\n}\n\n/**\n * An error result from the recognize entities operation on a single document.\n */\nexport type RecognizeCategorizedEntitiesErrorResult = TextAnalyticsErrorResult;\n\n/**\n * @internal\n */\nexport function makeRecognizeCategorizedEntitiesResult(\n  result: DocumentEntities\n): RecognizeCategorizedEntitiesSuccessResult {\n  const { entities, statistics, warnings, id } = result;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    entities\n  };\n}\n\n/**\n * @internal\n */\nexport function makeRecognizeCategorizedEntitiesErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): RecognizeCategorizedEntitiesErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TextDocumentBatchStatistics, TextDocumentInput, EntitiesResult } from \"./generated/models\";\nimport {\n  RecognizeCategorizedEntitiesResult,\n  makeRecognizeCategorizedEntitiesResult,\n  makeRecognizeCategorizedEntitiesErrorResult\n} from \"./recognizeCategorizedEntitiesResult\";\nimport { combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion } from \"./textAnalyticsResult\";\n\n/**\n * Array of `RecognizeCategorizedEntitiesResult` objects corresponding to a batch of input documents, and\n * annotated with information about the batch operation.\n */\nexport interface RecognizeCategorizedEntitiesResultArray\n  extends Array<RecognizeCategorizedEntitiesResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport function makeRecognizeCategorizedEntitiesResultArray(\n  input: TextDocumentInput[],\n  response: EntitiesResult\n): RecognizeCategorizedEntitiesResultArray {\n  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(\n    input,\n    response,\n    makeRecognizeCategorizedEntitiesResult,\n    makeRecognizeCategorizedEntitiesErrorResult\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport {\n  TextAnalyticsError,\n  DocumentSentimentLabel,\n  SentimentConfidenceScores,\n  SentenceSentiment as GeneratedSentenceSentiment,\n  SentenceSentimentLabel,\n  DocumentSentiment,\n  SentenceTarget,\n  TargetRelation,\n  SentenceAssessment,\n  TokenSentimentValue as SentenceTargetSentiment,\n  TargetConfidenceScoreLabel\n} from \"./generated/models\";\nimport { AssessmentIndex, parseAssessmentIndex } from \"./util\";\n\n/**\n * The result of the analyze sentiment operation on a single document.\n */\nexport type AnalyzeSentimentResult = AnalyzeSentimentSuccessResult | AnalyzeSentimentErrorResult;\n\n/**\n *  The result of the analyze sentiment operation on a single document,\n *  containing the predicted sentiment for each sentence as well as for the full document.\n */\nexport interface AnalyzeSentimentSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * Predicted sentiment for document. Possible values\n   * include: 'positive', 'neutral', 'negative', 'mixed'\n   */\n  sentiment: DocumentSentimentLabel;\n  /**\n   * Document level sentiment confidence scores between 0 and 1 for each sentiment class.\n   */\n  confidenceScores: SentimentConfidenceScores;\n  /**\n   * The predicted sentiment for each sentence in the corresponding document.\n   */\n  sentences: SentenceSentiment[];\n}\n\n/**\n * The predicted sentiment for a given span of text. For more information regarding text sentiment, see https://docs.microsoft.com/azure/cognitive-services/Text-Analytics/how-tos/text-analytics-how-to-sentiment-analysis.\n */\nexport interface SentenceSentiment {\n  /**\n   * The sentence text.\n   */\n  text: string;\n  /**\n   * The predicted Sentiment for the sentence.\n   */\n  sentiment: SentenceSentimentLabel;\n  /**\n   * The sentiment confidence score between 0 and 1 for the sentence for all classes.\n   */\n  confidenceScores: SentimentConfidenceScores;\n  /**\n   * The sentence text offset from the start of the document.\n   */\n  offset: number;\n  /**\n   * The length of the sentence text.\n   */\n  length: number;\n  /**\n   * The list of opinions mined from this sentence. For example in \"The food is\n   * good, but the service is bad\", we would mine these two opinions \"food is\n   * good\", \"service is bad\". Only returned if `includeOpinionMining` is set to\n   * True in the call to `analyzeSentiment`.\n   */\n  opinions: Opinion[];\n}\n\n/**\n * TargetSentiment contains the predicted sentiment, confidence scores and other\n * information about an target of a product. A target of a product/service is a\n * key component of that product/service. For example in \"The food at Hotel Foo\n * is good\", \"food\" is a target of \"Hotel Foo\".\n */\nexport interface TargetSentiment {\n  /**\n   * The sentiment confidence score between 0 and 1 for the target for\n   * 'positive' and 'negative' labels.\n   */\n  confidenceScores: TargetConfidenceScoreLabel;\n  /**\n   * The predicted Sentiment for the Target. Possible values include 'positive',\n   * 'mixed', and 'negative'.\n   */\n  sentiment: SentenceTargetSentiment;\n  /**\n   * The target text.\n   */\n  text: string;\n  /**\n   * The Target text offset from the start of the sentence.\n   */\n  offset: number;\n  /**\n   * The length of the Target text.\n   */\n  length: number;\n}\n\n/**\n * AssessmentSentiment contains the predicted sentiment, confidence scores and\n * other information about an assessment of a target. For example, in the sentence\n * \"The food is good\", the assessment of the target 'food' is 'good'.\n */\nexport interface AssessmentSentiment extends SentenceAssessment {}\n\n/**\n * A mined opinion object represents an opinion we've extracted from a sentence.\n * It consists of both a target that these assessments are about, and the actual\n * assessments themselves.\n */\nexport interface Opinion {\n  /**\n   * The target of a product/service that this assessment is about.\n   */\n  target: TargetSentiment;\n  /**\n   * The actual assessments of the target.\n   */\n  assessments: AssessmentSentiment[];\n}\n\n/**\n * An error result from the analyze sentiment operation on a single document.\n */\nexport type AnalyzeSentimentErrorResult = TextAnalyticsErrorResult;\n\n/**\n * @param document - A document result coming from the service.\n * @internal\n */\nexport function makeAnalyzeSentimentResult(\n  result: DocumentSentiment\n): AnalyzeSentimentSuccessResult {\n  const {\n    id,\n    sentiment,\n    confidenceScores,\n    sentenceSentiments: sentences,\n    warnings,\n    statistics\n  } = result;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    sentiment,\n    confidenceScores,\n    sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, result))\n  };\n}\n\n/**\n * @internal\n */\nexport function makeAnalyzeSentimentErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): AnalyzeSentimentErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n\n/**\n * Converts a sentence sentiment object returned by the service to another that\n * is user-friendly.\n *\n * @param sentence - The sentence sentiment object to be converted.\n * @param response - The entire response returned by the service.\n * @returns The user-friendly sentence sentiment object.\n * @internal\n */\nfunction convertGeneratedSentenceSentiment(\n  sentence: GeneratedSentenceSentiment,\n  result: DocumentSentiment\n): SentenceSentiment {\n  return {\n    confidenceScores: sentence.confidenceScores,\n    sentiment: sentence.sentiment,\n    text: sentence.text,\n    offset: sentence.offset,\n    length: sentence.length,\n    opinions: sentence.targets\n      ? sentence.targets.map(\n          (target: SentenceTarget): Opinion => ({\n            target: {\n              confidenceScores: target.confidenceScores,\n              sentiment: target.sentiment,\n              text: target.text,\n              offset: target.offset,\n              length: target.length\n            },\n            assessments: target.relations\n              .filter((relation) => relation.relationType === \"assessment\")\n              .map((relation) => convertTargetRelationToAssessmentSentiment(relation, result))\n          })\n        )\n      : []\n  };\n}\n\n/**\n * Converts a target relation object returned by the service to an assessment\n * sentiment object where JSON pointers in the former are realized in the\n * latter.\n *\n * @param targetRelation - The target relation object to be converted.\n * @param response - The entire response returned by the service.\n * @returns The user-friendly assessment sentiment object.\n * @internal\n */\nfunction convertTargetRelationToAssessmentSentiment(\n  targetRelation: TargetRelation,\n  result: DocumentSentiment\n): AssessmentSentiment {\n  const assessmentPtr = targetRelation.ref;\n  const assessmentIndex: AssessmentIndex = parseAssessmentIndex(assessmentPtr);\n  const assessment: SentenceAssessment | undefined =\n    result.sentenceSentiments?.[assessmentIndex.sentence].assessments?.[assessmentIndex.assessment];\n  if (assessment !== undefined) {\n    return assessment;\n  } else {\n    throw new Error(`Pointer \"${assessmentPtr}\" is not a valid Assessment pointer`);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TextDocumentBatchStatistics,\n  TextDocumentInput,\n  SentimentResponse\n} from \"./generated/models\";\nimport {\n  AnalyzeSentimentResult,\n  makeAnalyzeSentimentErrorResult,\n  makeAnalyzeSentimentResult\n} from \"./analyzeSentimentResult\";\nimport { combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion } from \"./textAnalyticsResult\";\n\n/**\n * Array of `AnalyzeSentimentResult` objects corresponding to a batch of input documents, and\n * annotated with information about the batch operation.\n */\nexport interface AnalyzeSentimentResultArray extends Array<AnalyzeSentimentResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport function makeAnalyzeSentimentResultArray(\n  input: TextDocumentInput[],\n  response: SentimentResponse\n): AnalyzeSentimentResultArray {\n  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(\n    input,\n    response,\n    makeAnalyzeSentimentResult,\n    makeAnalyzeSentimentErrorResult\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport { TextAnalyticsError, DocumentKeyPhrases } from \"./generated/models\";\n\n/**\n * The result of the extract key phrases operation on a single document.\n */\nexport type ExtractKeyPhrasesResult = ExtractKeyPhrasesSuccessResult | ExtractKeyPhrasesErrorResult;\n\n/**\n * The result of the extract key phrases operation on a single document,\n * containing a collection of the key phrases identified in that document.\n */\nexport interface ExtractKeyPhrasesSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * A list of representative words or phrases. The number of key phrases returned is proportional\n   * to the number of words in the input document.\n   */\n  keyPhrases: string[];\n}\n\n/**\n * An error result from the extract key phrases operation on a single document.\n */\nexport type ExtractKeyPhrasesErrorResult = TextAnalyticsErrorResult;\n\n/**\n * @internal\n */\nexport function makeExtractKeyPhrasesResult(\n  result: DocumentKeyPhrases\n): ExtractKeyPhrasesSuccessResult {\n  const { id, warnings, statistics, keyPhrases } = result;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    keyPhrases\n  };\n}\n\n/**\n * @internal\n */\nexport function makeExtractKeyPhrasesErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): ExtractKeyPhrasesErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TextDocumentBatchStatistics,\n  TextDocumentInput,\n  KeyPhraseResult\n} from \"./generated/models\";\nimport {\n  ExtractKeyPhrasesResult,\n  makeExtractKeyPhrasesResult,\n  makeExtractKeyPhrasesErrorResult\n} from \"./extractKeyPhrasesResult\";\nimport { combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion } from \"./textAnalyticsResult\";\n\n/**\n * Array of `ExtractKeyPhrasesResult` objects corresponding to a batch of input documents, and\n * annotated with information about the batch operation.\n */\nexport interface ExtractKeyPhrasesResultArray extends Array<ExtractKeyPhrasesResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport function makeExtractKeyPhrasesResultArray(\n  input: TextDocumentInput[],\n  response: KeyPhraseResult\n): ExtractKeyPhrasesResultArray {\n  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(\n    input,\n    response,\n    makeExtractKeyPhrasesResult,\n    makeExtractKeyPhrasesErrorResult\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport { Entity, PiiDocumentEntities, TextAnalyticsError } from \"./generated/models\";\n\n/**\n * An entity from PII recognition with information about the kind of PII\n * encountered.\n */\nexport interface PiiEntity extends Entity {}\n\n/**\n * The result of the recognize entities operation on a single document.\n */\nexport type RecognizePiiEntitiesResult =\n  | RecognizePiiEntitiesSuccessResult\n  | RecognizePiiEntitiesErrorResult;\n\n/**\n * The result of the recognize entities operation on a single document, containing the collection of\n * `Entity` objects identified in that document.\n */\nexport interface RecognizePiiEntitiesSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * The collection of entities identified in the input document.\n   */\n  readonly entities: PiiEntity[];\n  /**\n   * The text redacted.\n   */\n  redactedText: string;\n}\n\n/**\n * An error result from the recognize entities operation on a single document.\n */\nexport type RecognizePiiEntitiesErrorResult = TextAnalyticsErrorResult;\n\n/**\n * @internal\n */\nexport function makeRecognizePiiEntitiesResult(\n  document: PiiDocumentEntities\n): RecognizePiiEntitiesSuccessResult {\n  const { id, entities, warnings, statistics, redactedText } = document;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    entities,\n    redactedText\n  };\n}\n\n/**\n * @internal\n */\nexport function makeRecognizePiiEntitiesErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): RecognizePiiEntitiesErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TextDocumentBatchStatistics, TextDocumentInput, PiiResult } from \"./generated/models\";\nimport {\n  RecognizePiiEntitiesResult,\n  makeRecognizePiiEntitiesResult,\n  makeRecognizePiiEntitiesErrorResult\n} from \"./recognizePiiEntitiesResult\";\nimport { combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion } from \"./textAnalyticsResult\";\n\n/**\n * Collection of `RecognizePiiEntitiesResult` objects corresponding to a batch of input documents, and\n * annotated with information about the batch operation.\n */\nexport interface RecognizePiiEntitiesResultArray extends Array<RecognizePiiEntitiesResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport function makeRecognizePiiEntitiesResultArray(\n  input: TextDocumentInput[],\n  response: PiiResult\n): RecognizePiiEntitiesResultArray {\n  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(\n    input,\n    response,\n    makeRecognizePiiEntitiesResult,\n    makeRecognizePiiEntitiesErrorResult\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  makeTextAnalyticsErrorResult\n} from \"./textAnalyticsResult\";\nimport { TextAnalyticsError, LinkedEntity, DocumentLinkedEntities } from \"./generated/models\";\n\n/**\n * The result of the recognize linked entities operation on a single document.\n */\nexport type RecognizeLinkedEntitiesResult =\n  | RecognizeLinkedEntitiesSuccessResult\n  | RecognizeLinkedEntitiesErrorResult;\n\n/**\n * The result of the recognize linked entities operation on a single document,\n * containing a collection of the `LinkedEntity` objects identified in that document.\n */\nexport interface RecognizeLinkedEntitiesSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * The collection of entities identified in the input document.\n   */\n  readonly entities: LinkedEntity[];\n}\n\n/**\n * An error result from the recognize linked entities operation on a single document.\n */\nexport type RecognizeLinkedEntitiesErrorResult = TextAnalyticsErrorResult;\n\n/**\n * @internal\n */\nexport function makeRecognizeLinkedEntitiesResult(\n  result: DocumentLinkedEntities\n): RecognizeLinkedEntitiesSuccessResult {\n  const { statistics, id, warnings, entities } = result;\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    entities\n  };\n}\n\n/**\n * @internal\n */\nexport function makeRecognizeLinkedEntitiesErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): RecognizeLinkedEntitiesErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  TextDocumentBatchStatistics,\n  TextDocumentInput,\n  EntityLinkingResult\n} from \"./generated/models\";\nimport {\n  RecognizeLinkedEntitiesResult,\n  makeRecognizeLinkedEntitiesResult,\n  makeRecognizeLinkedEntitiesErrorResult\n} from \"./recognizeLinkedEntitiesResult\";\nimport { combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion } from \"./textAnalyticsResult\";\n\n/**\n * Array of `RecognizeLinkedEntitiesResult` objects corresponding to a batch of input documents, and\n * annotated with information about the batch operation.\n */\nexport interface RecognizeLinkedEntitiesResultArray extends Array<RecognizeLinkedEntitiesResult> {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * @internal\n */\nexport function makeRecognizeLinkedEntitiesResultArray(\n  input: TextDocumentInput[],\n  response: EntityLinkingResult\n): RecognizeLinkedEntitiesResultArray {\n  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(\n    input,\n    response,\n    makeRecognizeLinkedEntitiesResult,\n    makeRecognizeLinkedEntitiesErrorResult\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  Span,\n  SpanContext,\n  SpanAttributes,\n  SpanStatus,\n  TraceFlags,\n  Exception,\n  TimeInput\n} from \"../../interfaces\";\n\n/**\n * A no-op implementation of Span that can safely be used without side-effects.\n */\nexport class NoOpSpan implements Span {\n  /**\n   * Returns the SpanContext associated with this Span.\n   */\n  spanContext(): SpanContext {\n    return {\n      spanId: \"\",\n      traceId: \"\",\n      traceFlags: TraceFlags.NONE\n    };\n  }\n\n  /**\n   * Marks the end of Span execution.\n   * @param _endTime - The time to use as the Span's end time. Defaults to\n   * the current time.\n   */\n  end(_endTime?: number): void {\n    /* Noop */\n  }\n\n  /**\n   * Sets an attribute on the Span\n   * @param _key - The attribute key\n   * @param _value - The attribute value\n   */\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  /**\n   * Sets attributes on the Span\n   * @param _attributes - The attributes to add\n   */\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  /**\n   * Adds an event to the Span\n   * @param _name - The name of the event\n   * @param _attributes - The associated attributes to add for this event\n   */\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  /**\n   * Sets a status on the span. Overrides the default of SpanStatusCode.OK.\n   * @param _status - The status to set.\n   */\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  /**\n   * Updates the name of the Span\n   * @param _name - the new Span name\n   */\n  updateName(_name: string): this {\n    return this;\n  }\n\n  /**\n   * Returns whether this span will be recorded\n   */\n  isRecording(): boolean {\n    return false;\n  }\n\n  /**\n   * Sets exception as a span event\n   * @param exception - the exception the only accepted values are string or Error\n   * @param time - the time to set as Span's event time. If not provided,\n   *     use the current time.\n   */\n  recordException(_exception: Exception, _time?: TimeInput): void {\n    /* do nothing */\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { NoOpSpan } from \"./noOpSpan\";\nimport { Span, SpanOptions, Tracer } from \"../../interfaces\";\n\n/**\n * A no-op implementation of Tracer that can be used when tracing\n * is disabled.\n */\nexport class NoOpTracer implements Tracer {\n  /**\n   * Starts a new Span.\n   * @param _name - The name of the span.\n   * @param _options - The SpanOptions used during Span creation.\n   */\n  startSpan(_name: string, _options?: SpanOptions): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Returns the current Span from the current context, if available.\n   */\n  getCurrentSpan(): Span {\n    return new NoOpSpan();\n  }\n\n  /**\n   * Executes the given function within the context provided by a Span.\n   * @param _span - The span that provides the context.\n   * @param fn - The function to be executed.\n   */\n  withSpan<T extends (...args: unknown[]) => ReturnType<T>>(_span: Span, fn: T): ReturnType<T> {\n    return fn();\n  }\n\n  /**\n   * Bind a Span as the target's scope\n   * @param target - An object to bind the scope.\n   * @param _span - A specific Span to use. Otherwise, use the current one.\n   */\n  bind<T>(target: T, _span?: Span): T {\n    return target;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport function getGlobalObject(): any {\n  return self;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Tracer } from \"../interfaces\";\nimport { getGlobalObject } from \"./global\";\n\n// tracerCache will be updated when a new incompatible version of OTel is\n// shipped in core-tracing.\n// tracerCache3 - OpenTelemetry 1.0.0-rc.1\n// tracerCache4 - OpenTelemetry 0.20.0\nconst GLOBAL_TRACER_SYMBOL = Symbol.for(`@azure/core-tracing.tracerCache4`);\n\nexport interface TracerCache {\n  tracer?: Tracer;\n}\n\nlet cache: TracerCache;\n\nfunction loadTracerCache(): void {\n  const globalObj = getGlobalObject();\n\n  if (!globalObj[GLOBAL_TRACER_SYMBOL]) {\n    globalObj[GLOBAL_TRACER_SYMBOL] = {\n      tracer: undefined\n    };\n  }\n  cache = globalObj[GLOBAL_TRACER_SYMBOL];\n}\n\nexport function getCache(): TracerCache {\n  if (!cache) {\n    loadTracerCache();\n  }\n  return cache;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { NoOpTracer } from \"./tracers/noop/noOpTracer\";\nimport { Tracer } from \"./interfaces\";\nimport { getCache } from \"./utils/cache\";\n\nlet defaultTracer: Tracer;\n\nfunction getDefaultTracer(): Tracer {\n  if (!defaultTracer) {\n    defaultTracer = new NoOpTracer();\n  }\n  return defaultTracer;\n}\n\n/**\n * Sets the global tracer, enabling tracing for the Azure SDK.\n * @param tracer - An OpenTelemetry Tracer instance.\n */\nexport function setTracer(tracer: Tracer): void {\n  const cache = getCache();\n  cache.tracer = tracer;\n}\n\n/**\n * Retrieves the active tracer, or returns a\n * no-op implementation if one is not set.\n */\nexport function getTracer(): Tracer {\n  const cache = getCache();\n  if (!cache.tracer) {\n    return getDefaultTracer();\n  }\n  return cache.tracer;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Updates to this file should also be replicated to @opentelemetry/core too.\n\n/**\n * - globalThis (New standard)\n * - self (Will return the current window instance for supported browsers)\n * - window (fallback for older browser implementations)\n * - global (NodeJS implementation)\n * - <object> (When all else fails)\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef\nexport const _globalThis: typeof globalThis =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof self === 'object'\n    ? self\n    : typeof window === 'object'\n    ? window\n    : typeof global === 'object'\n    ? global\n    : ({} as typeof globalThis);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.7.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Baggage, BaggageEntry } from '../types';\n\nexport class BaggageImpl implements Baggage {\n  private _entries: Map<string, BaggageEntry>;\n\n  constructor(entries?: Map<string, BaggageEntry>) {\n    this._entries = entries ? new Map(entries) : new Map();\n  }\n\n  getEntry(key: string): BaggageEntry | undefined {\n    const entry = this._entries.get(key);\n    if (!entry) {\n      return undefined;\n    }\n\n    return Object.assign({}, entry);\n  }\n\n  getAllEntries(): [string, BaggageEntry][] {\n    return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);\n  }\n\n  setEntry(key: string, entry: BaggageEntry): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.set(key, entry);\n    return newBaggage;\n  }\n\n  removeEntry(key: string): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    newBaggage._entries.delete(key);\n    return newBaggage;\n  }\n\n  removeEntries(...keys: string[]): BaggageImpl {\n    const newBaggage = new BaggageImpl(this._entries);\n    for (const key of keys) {\n      newBaggage._entries.delete(key);\n    }\n    return newBaggage;\n  }\n\n  clear(): BaggageImpl {\n    return new BaggageImpl();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Symbol used to make BaggageEntryMetadata an opaque type\n */\nexport const baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagAPI } from '../api/diag';\nimport { BaggageImpl } from './internal/baggage-impl';\nimport { baggageEntryMetadataSymbol } from './internal/symbol';\nimport { Baggage, BaggageEntry, BaggageEntryMetadata } from './types';\n\nconst diag = DiagAPI.instance();\n\n/**\n * Create a new Baggage with optional entries\n *\n * @param entries An array of baggage entries the new baggage should contain\n */\nexport function createBaggage(\n  entries: Record<string, BaggageEntry> = {}\n): Baggage {\n  return new BaggageImpl(new Map(Object.entries(entries)));\n}\n\n/**\n * Create a serializable BaggageEntryMetadata object from a string.\n *\n * @param str string metadata. Format is currently not defined by the spec and has no special meaning.\n *\n */\nexport function baggageEntryMetadataFromString(\n  str: string\n): BaggageEntryMetadata {\n  if (typeof str !== 'string') {\n    diag.error(\n      `Cannot create baggage metadata from unknown type: ${typeof str}`\n    );\n    str = '';\n  }\n\n  return {\n    __TYPE__: baggageEntryMetadataSymbol,\n    toString() {\n      return str;\n    },\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogger, DiagLogFunction } from './types';\n\ntype ConsoleMapKeys = 'error' | 'warn' | 'info' | 'debug' | 'trace';\nconst consoleMap: { n: keyof DiagLogger; c: ConsoleMapKeys }[] = [\n  { n: 'error', c: 'error' },\n  { n: 'warn', c: 'warn' },\n  { n: 'info', c: 'info' },\n  { n: 'debug', c: 'debug' },\n  { n: 'verbose', c: 'trace' },\n];\n\n/**\n * A simple Immutable Console based diagnostic logger which will output any messages to the Console.\n * If you want to limit the amount of logging to a specific level or lower use the\n * {@link createLogLevelDiagLogger}\n */\nexport class DiagConsoleLogger implements DiagLogger {\n  constructor() {\n    function _consoleFunc(funcName: ConsoleMapKeys): DiagLogFunction {\n      return function (...args) {\n        if (console) {\n          // Some environments only expose the console when the F12 developer console is open\n          // eslint-disable-next-line no-console\n          let theFunc = console[funcName];\n          if (typeof theFunc !== 'function') {\n            // Not all environments support all functions\n            // eslint-disable-next-line no-console\n            theFunc = console.log;\n          }\n\n          // One last final check\n          if (typeof theFunc === 'function') {\n            return theFunc.apply(console, args);\n          }\n        }\n      };\n    }\n\n    for (let i = 0; i < consoleMap.length; i++) {\n      this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);\n    }\n  }\n\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  public error!: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  public warn!: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  public info!: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario. Useful scenarios would be to log the execution\n   * order of async operations\n   */\n  public debug!: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  public verbose!: DiagLogFunction;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter } from './Meter';\nimport {\n  BatchObservableCallback,\n  Counter,\n  Histogram,\n  MetricOptions,\n  ObservableCallback,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n  MetricAttributes,\n  Observable,\n} from './Metric';\n\n/**\n * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses\n * constant NoopMetrics for all of its methods.\n */\nexport class NoopMeter implements Meter {\n  constructor() {}\n\n  /**\n   * @see {@link Meter.createHistogram}\n   */\n  createHistogram(_name: string, _options?: MetricOptions): Histogram {\n    return NOOP_HISTOGRAM_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createCounter}\n   */\n  createCounter(_name: string, _options?: MetricOptions): Counter {\n    return NOOP_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createUpDownCounter}\n   */\n  createUpDownCounter(_name: string, _options?: MetricOptions): UpDownCounter {\n    return NOOP_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableGauge}\n   */\n  createObservableGauge(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableGauge {\n    return NOOP_OBSERVABLE_GAUGE_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableCounter}\n   */\n  createObservableCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableCounter {\n    return NOOP_OBSERVABLE_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.createObservableUpDownCounter}\n   */\n  createObservableUpDownCounter(\n    _name: string,\n    _options?: MetricOptions\n  ): ObservableUpDownCounter {\n    return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    _callback: BatchObservableCallback,\n    _observables: Observable[]\n  ): void {}\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(_callback: BatchObservableCallback): void {}\n}\n\nexport class NoopMetric {}\n\nexport class NoopCounterMetric extends NoopMetric implements Counter {\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopUpDownCounterMetric\n  extends NoopMetric\n  implements UpDownCounter\n{\n  add(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopHistogramMetric extends NoopMetric implements Histogram {\n  record(_value: number, _attributes: MetricAttributes): void {}\n}\n\nexport class NoopObservableMetric {\n  addCallback(_callback: ObservableCallback) {}\n\n  removeCallback(_callback: ObservableCallback) {}\n}\n\nexport class NoopObservableCounterMetric\n  extends NoopObservableMetric\n  implements ObservableCounter {}\n\nexport class NoopObservableGaugeMetric\n  extends NoopObservableMetric\n  implements ObservableGauge {}\n\nexport class NoopObservableUpDownCounterMetric\n  extends NoopObservableMetric\n  implements ObservableUpDownCounter {}\n\nexport const NOOP_METER = new NoopMeter();\n\n// Synchronous instruments\nexport const NOOP_COUNTER_METRIC = new NoopCounterMetric();\nexport const NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();\nexport const NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();\n\n// Asynchronous instruments\nexport const NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();\nexport const NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();\nexport const NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =\n  new NoopObservableUpDownCounterMetric();\n\n/**\n * Create a no-op Meter\n */\nexport function createNoopMeter(): Meter {\n  return NOOP_METER;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes, AttributeValue } from '../common/Attributes';\nimport { Context } from '../context/types';\nimport { BatchObservableResult, ObservableResult } from './ObservableResult';\n\n/**\n * Advisory options influencing aggregation configuration parameters.\n * @experimental\n */\nexport interface MetricAdvice {\n  /**\n   * Hint the explicit bucket boundaries for SDK if the metric is been\n   * aggregated with a HistogramAggregator.\n   */\n  explicitBucketBoundaries?: number[];\n}\n\n/**\n * Options needed for metric creation\n */\nexport interface MetricOptions {\n  /**\n   * The description of the Metric.\n   * @default ''\n   */\n  description?: string;\n\n  /**\n   * The unit of the Metric values.\n   * @default ''\n   */\n  unit?: string;\n\n  /**\n   * Indicates the type of the recorded value.\n   * @default {@link ValueType.DOUBLE}\n   */\n  valueType?: ValueType;\n\n  /**\n   * The advice influencing aggregation configuration parameters.\n   * @experimental\n   */\n  advice?: MetricAdvice;\n}\n\n/** The Type of value. It describes how the data is reported. */\nexport enum ValueType {\n  INT,\n  DOUBLE,\n}\n\n/**\n * Counter is the most common synchronous instrument. This instrument supports\n * an `Add(increment)` function for reporting a sum, and is restricted to\n * non-negative increments. The default aggregation is Sum, as for any additive\n * instrument.\n *\n * Example uses for Counter:\n * <ol>\n *   <li> count the number of bytes received. </li>\n *   <li> count the number of requests completed. </li>\n *   <li> count the number of accounts created. </li>\n *   <li> count the number of checkpoints run. </li>\n *   <li> count the number of 5xx errors. </li>\n * <ol>\n */\nexport interface Counter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs must not be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface UpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\nexport interface Histogram<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: AttributesTypes, context?: Context): void;\n}\n\n/**\n * @deprecated please use {@link Attributes}\n */\nexport type MetricAttributes = Attributes;\n\n/**\n * @deprecated please use {@link AttributeValue}\n */\nexport type MetricAttributeValue = AttributeValue;\n\n/**\n * The observable callback for Observable instruments.\n */\nexport type ObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: ObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\n/**\n * The observable callback for a batch of Observable instruments.\n */\nexport type BatchObservableCallback<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = (\n  observableResult: BatchObservableResult<AttributesTypes>\n) => void | Promise<void>;\n\nexport interface Observable<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> {\n  /**\n   * Sets up a function that will be called whenever a metric collection is initiated.\n   *\n   * If the function is already in the list of callbacks for this Observable, the function is not added a second time.\n   */\n  addCallback(callback: ObservableCallback<AttributesTypes>): void;\n\n  /**\n   * Removes a callback previously registered with {@link Observable.addCallback}.\n   */\n  removeCallback(callback: ObservableCallback<AttributesTypes>): void;\n}\n\nexport type ObservableCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableUpDownCounter<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\nexport type ObservableGauge<\n  AttributesTypes extends MetricAttributes = MetricAttributes,\n> = Observable<AttributesTypes>;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\n\n/**\n * Injects `Context` into and extracts it from carriers that travel\n * in-band across process boundaries. Encoding is expected to conform to the\n * HTTP Header Field semantics. Values are often encoded as RPC/HTTP request\n * headers.\n *\n * The carrier of propagated data on both the client (injector) and server\n * (extractor) side is usually an object such as http headers. Propagation is\n * usually implemented via library-specific request interceptors, where the\n * client-side injects values and the server-side extracts them.\n */\nexport interface TextMapPropagator<Carrier = any> {\n  /**\n   * Injects values from a given `Context` into a carrier.\n   *\n   * OpenTelemetry defines a common set of format values (TextMapPropagator),\n   * and each has an expected `carrier` type.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param setter an optional {@link TextMapSetter}. If undefined, values will be\n   *     set by direct object assignment.\n   */\n  inject(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier>\n  ): void;\n\n  /**\n   * Given a `Context` and a carrier, extract context values from a\n   * carrier and return a new context, created from the old context, with the\n   * extracted values.\n   *\n   * @param context the Context from which to extract values to transmit over\n   *     the wire.\n   * @param carrier the carrier of propagation fields, such as http request\n   *     headers.\n   * @param getter an optional {@link TextMapGetter}. If undefined, keys will be all\n   *     own properties, and keys will be accessed by direct object access.\n   */\n  extract(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier>\n  ): Context;\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  fields(): string[];\n}\n\n/**\n * A setter is specified by the caller to define a specific method\n * to set key/value pairs on the carrier within a propagator.\n */\nexport interface TextMapSetter<Carrier = any> {\n  /**\n   * Callback used to set a key/value pair on an object.\n   *\n   * Should be called by the propagator each time a key/value pair\n   * should be set, and should set that key/value pair on the propagator.\n   *\n   * @param carrier object or class which carries key/value pairs\n   * @param key string key to modify\n   * @param value value to be set to the key on the carrier\n   */\n  set(carrier: Carrier, key: string, value: string): void;\n}\n\n/**\n * A getter is specified by the caller to define a specific method\n * to get the value of a key from a carrier.\n */\nexport interface TextMapGetter<Carrier = any> {\n  /**\n   * Get a list of all keys available on the carrier.\n   *\n   * @param carrier\n   */\n  keys(carrier: Carrier): string[];\n\n  /**\n   * Get the value of a specific key from the carrier.\n   *\n   * @param carrier\n   * @param key\n   */\n  get(carrier: Carrier, key: string): undefined | string | string[];\n}\n\nexport const defaultTextMapGetter: TextMapGetter = {\n  get(carrier, key) {\n    if (carrier == null) {\n      return undefined;\n    }\n    return carrier[key];\n  },\n\n  keys(carrier) {\n    if (carrier == null) {\n      return [];\n    }\n    return Object.keys(carrier);\n  },\n};\n\nexport const defaultTextMapSetter: TextMapSetter = {\n  set(carrier, key, value) {\n    if (carrier == null) {\n      return;\n    }\n\n    carrier[key] = value;\n  },\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes } from './attributes';\nimport { TraceState } from './trace_state';\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';\nconst VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;\nconst VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;\nconst VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);\nconst VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;\nconst INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;\n\n/**\n * Key is opaque string up to 256 characters printable. It MUST begin with a\n * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,\n * underscores _, dashes -, asterisks *, and forward slashes /.\n * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the\n * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.\n * see https://www.w3.org/TR/trace-context/#key\n */\nexport function validateKey(key: string): boolean {\n  return VALID_KEY_REGEX.test(key);\n}\n\n/**\n * Value is opaque string up to 256 characters printable ASCII RFC0020\n * characters (i.e., the range 0x20 to 0x7E) except comma , and =.\n */\nexport function validateValue(value: string): boolean {\n  return (\n    VALID_VALUE_BASE_REGEX.test(value) &&\n    !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value)\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { DiagAPI } from './api/diag';\n/**\n * Entrypoint for Diag API.\n * Defines Diagnostic handler used for internal diagnostic logging operations.\n * The default provides a Noop DiagLogger implementation which may be changed via the\n * diag.setLogger(logger: DiagLogger) function.\n */\nexport const diag = DiagAPI.instance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from './Meter';\nimport { MeterProvider } from './MeterProvider';\nimport { NOOP_METER } from './NoopMeter';\n\n/**\n * An implementation of the {@link MeterProvider} which returns an impotent Meter\n * for all calls to `getMeter`\n */\nexport class NoopMeterProvider implements MeterProvider {\n  getMeter(_name: string, _version?: string, _options?: MeterOptions): Meter {\n    return NOOP_METER;\n  }\n}\n\nexport const NOOP_METER_PROVIDER = new NoopMeterProvider();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Meter, MeterOptions } from '../metrics/Meter';\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { NOOP_METER_PROVIDER } from '../metrics/NoopMeterProvider';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'metrics';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Metrics API\n */\nexport class MetricsAPI {\n  private static _instance?: MetricsAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Metrics API */\n  public static getInstance(): MetricsAPI {\n    if (!this._instance) {\n      this._instance = new MetricsAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global meter provider.\n   * Returns true if the meter provider was successfully registered, else false.\n   */\n  public setGlobalMeterProvider(provider: MeterProvider): boolean {\n    return registerGlobal(API_NAME, provider, DiagAPI.instance());\n  }\n\n  /**\n   * Returns the global meter provider.\n   */\n  public getMeterProvider(): MeterProvider {\n    return getGlobal(API_NAME) || NOOP_METER_PROVIDER;\n  }\n\n  /**\n   * Returns a meter from the global meter provider.\n   */\n  public getMeter(\n    name: string,\n    version?: string,\n    options?: MeterOptions\n  ): Meter {\n    return this.getMeterProvider().getMeter(name, version, options);\n  }\n\n  /** Remove the global meter provider */\n  public disable(): void {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { MetricsAPI } from './api/metrics';\n/** Entrypoint for metrics API */\nexport const metrics = MetricsAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { TextMapPropagator } from './TextMapPropagator';\n\n/**\n * No-op implementations of {@link TextMapPropagator}.\n */\nexport class NoopTextMapPropagator implements TextMapPropagator {\n  /** Noop inject function does nothing */\n  inject(_context: Context, _carrier: unknown): void {}\n  /** Noop extract function does nothing and returns the input context */\n  extract(context: Context, _carrier: unknown): Context {\n    return context;\n  }\n  fields(): string[] {\n    return [];\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Baggage } from './types';\n\n/**\n * Baggage key\n */\nconst BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');\n\n/**\n * Retrieve the current baggage from the given context\n *\n * @param {Context} Context that manage all context values\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getBaggage(context: Context): Baggage | undefined {\n  return (context.getValue(BAGGAGE_KEY) as Baggage) || undefined;\n}\n\n/**\n * Retrieve the current baggage from the active/current context\n *\n * @returns {Baggage} Extracted baggage from the context\n */\nexport function getActiveBaggage(): Baggage | undefined {\n  return getBaggage(ContextAPI.getInstance().active());\n}\n\n/**\n * Store a baggage in the given context\n *\n * @param {Context} Context that manage all context values\n * @param {Baggage} baggage that will be set in the actual context\n */\nexport function setBaggage(context: Context, baggage: Baggage): Context {\n  return context.setValue(BAGGAGE_KEY, baggage);\n}\n\n/**\n * Delete the baggage stored in the given context\n *\n * @param {Context} Context that manage all context values\n */\nexport function deleteBaggage(context: Context): Context {\n  return context.deleteValue(BAGGAGE_KEY);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { NoopTextMapPropagator } from '../propagation/NoopTextMapPropagator';\nimport {\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n} from '../propagation/TextMapPropagator';\nimport {\n  getBaggage,\n  getActiveBaggage,\n  setBaggage,\n  deleteBaggage,\n} from '../baggage/context-helpers';\nimport { createBaggage } from '../baggage/utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'propagation';\nconst NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Propagation API\n */\nexport class PropagationAPI {\n  private static _instance?: PropagationAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Propagator API */\n  public static getInstance(): PropagationAPI {\n    if (!this._instance) {\n      this._instance = new PropagationAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current propagator.\n   *\n   * @returns true if the propagator was successfully registered, else false\n   */\n  public setGlobalPropagator(propagator: TextMapPropagator): boolean {\n    return registerGlobal(API_NAME, propagator, DiagAPI.instance());\n  }\n\n  /**\n   * Inject context into a carrier to be propagated inter-process\n   *\n   * @param context Context carrying tracing data to inject\n   * @param carrier carrier to inject context into\n   * @param setter Function used to set values on the carrier\n   */\n  public inject<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    setter: TextMapSetter<Carrier> = defaultTextMapSetter\n  ): void {\n    return this._getGlobalPropagator().inject(context, carrier, setter);\n  }\n\n  /**\n   * Extract context from a carrier\n   *\n   * @param context Context which the newly created context will inherit from\n   * @param carrier Carrier to extract context from\n   * @param getter Function used to extract keys from a carrier\n   */\n  public extract<Carrier>(\n    context: Context,\n    carrier: Carrier,\n    getter: TextMapGetter<Carrier> = defaultTextMapGetter\n  ): Context {\n    return this._getGlobalPropagator().extract(context, carrier, getter);\n  }\n\n  /**\n   * Return a list of all fields which may be used by the propagator.\n   */\n  public fields(): string[] {\n    return this._getGlobalPropagator().fields();\n  }\n\n  /** Remove the global propagator */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n\n  public createBaggage = createBaggage;\n\n  public getBaggage = getBaggage;\n\n  public getActiveBaggage = getActiveBaggage;\n\n  public setBaggage = setBaggage;\n\n  public deleteBaggage = deleteBaggage;\n\n  private _getGlobalPropagator(): TextMapPropagator {\n    return getGlobal(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { PropagationAPI } from './api/propagation';\n/** Entrypoint for propagation API */\nexport const propagation = PropagationAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { context as otContext, trace as otTrace } from \"@opentelemetry/api\";\n\n/**\n * A Tracer.\n */\nexport interface Tracer {\n  /**\n   * Starts a new {@link Span}. Start the span without setting it on context.\n   *\n   * This method does NOT modify the current Context.\n   *\n   * @param name - The name of the span\n   * @param options - SpanOptions used for span creation\n   * @param context - Context to use to extract parent\n   * @returns The newly created span\n   * @example\n   *     const span = tracer.startSpan('op');\n   *     span.setAttribute('key', 'value');\n   *     span.end();\n   */\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span;\n}\n\n/**\n * TraceState.\n */\nexport interface TraceState {\n  /**\n   * Create a new TraceState which inherits from this TraceState and has the\n   * given key set.\n   * The new entry will always be added in the front of the list of states.\n   *\n   * @param key - key of the TraceState entry.\n   * @param value - value of the TraceState entry.\n   */\n  set(key: string, value: string): TraceState;\n  /**\n   * Return a new TraceState which inherits from this TraceState but does not\n   * contain the given key.\n   *\n   * @param key - the key for the TraceState entry to be removed.\n   */\n  unset(key: string): TraceState;\n  /**\n   * Returns the value to which the specified key is mapped, or `undefined` if\n   * this map contains no mapping for the key.\n   *\n   * @param key - with which the specified value is to be associated.\n   * @returns the value to which the specified key is mapped, or `undefined` if\n   *     this map contains no mapping for the key.\n   */\n  get(key: string): string | undefined;\n  /**\n   * Serializes the TraceState to a `list` as defined below. The `list` is a\n   * series of `list-members` separated by commas `,`, and a list-member is a\n   * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\n   * surrounding `list-members` are ignored. There can be a maximum of 32\n   * `list-members` in a `list`.\n   *\n   * @returns the serialized string.\n   */\n  serialize(): string;\n}\n\n/**\n * Represents high resolution time.\n */\nexport declare type HrTime = [number, number];\n\n/**\n * Used to represent a Time.\n */\nexport type TimeInput = HrTime | number | Date;\n\n/**\n * The status for a span.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * The kind of span.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4\n}\n\n/**\n * An Exception for a Span.\n */\nexport declare type Exception =\n  | ExceptionWithCode\n  | ExceptionWithMessage\n  | ExceptionWithName\n  | string;\n\n/**\n * An Exception with a code.\n */\nexport interface ExceptionWithCode {\n  /** The code. */\n  code: string | number;\n  /** The name. */\n  name?: string;\n  /** The message. */\n  message?: string;\n  /** The stack. */\n  stack?: string;\n}\n\n/**\n * An Exception with a message.\n */\nexport interface ExceptionWithMessage {\n  /** The code. */\n  code?: string | number;\n  /** The message. */\n  message: string;\n  /** The name. */\n  name?: string;\n  /** The stack. */\n  stack?: string;\n}\n\n/**\n * An Exception with a name.\n */\nexport interface ExceptionWithName {\n  /** The code. */\n  code?: string | number;\n  /** The message. */\n  message?: string;\n  /** The name. */\n  name: string;\n  /** The stack. */\n  stack?: string;\n}\n\n/**\n * Return the span if one exists\n *\n * @param context - context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return otTrace.getSpan(context);\n}\n\n/**\n * Set the span on a context\n *\n * @param context - context to use as parent\n * @param span - span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return otTrace.setSpan(context, span);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context - context to set active span on\n * @param spanContext - span context to be wrapped\n */\nexport function setSpanContext(context: Context, spanContext: SpanContext): Context {\n  return otTrace.setSpanContext(context, spanContext);\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context - context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return otTrace.getSpanContext(context);\n}\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport interface ContextAPI {\n  /**\n   * Get the currently active context\n   */\n  active(): Context;\n}\n\n/** Entrypoint for context API */\nexport const context: ContextAPI = otContext;\n\n/** SpanStatusCode */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2\n}\n\n/**\n * An interface that represents a span. A span represents a single operation\n * within a trace. Examples of span might include remote procedure calls or a\n * in-process function calls to sub-components. A Trace has a single, top-level\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\n * may have children.\n *\n * Spans are created by the {@link Tracer.startSpan} method.\n */\nexport interface Span {\n  /**\n   * Returns the {@link SpanContext} object associated with this Span.\n   *\n   * Get an immutable, serializable identifier for this span that can be used\n   * to create new child spans. Returned SpanContext is usable even after the\n   * span ends.\n   *\n   * @returns the SpanContext object associated with this Span.\n   */\n  spanContext(): SpanContext;\n  /**\n   * Sets an attribute to the span.\n   *\n   * Sets a single Attribute with the key and value passed as arguments.\n   *\n   * @param key - the key for this attribute.\n   * @param value - the value for this attribute. Setting a value null or\n   *              undefined is invalid and will result in undefined behavior.\n   */\n  setAttribute(key: string, value: SpanAttributeValue): this;\n  /**\n   * Sets attributes to the span.\n   *\n   * @param attributes - the attributes that will be added.\n   *                   null or undefined attribute values\n   *                   are invalid and will result in undefined behavior.\n   */\n  setAttributes(attributes: SpanAttributes): this;\n  /**\n   * Adds an event to the Span.\n   *\n   * @param name - the name of the event.\n   * @param attributesOrStartTime -  the attributes that will be added; these are\n   *     associated with this event. Can be also a start time\n   *     if type is TimeInput and 3rd param is undefined\n   * @param startTime - start time of the event.\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: SpanAttributes | TimeInput,\n    startTime?: TimeInput\n  ): this;\n  /**\n   * Sets a status to the span. If used, this will override the default Span\n   * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\n   * of previous calls to SetStatus on the Span.\n   *\n   * @param status - the SpanStatus to set.\n   */\n  setStatus(status: SpanStatus): this;\n  /**\n   * Marks the end of Span execution.\n   *\n   * Call to End of a Span MUST not have any effects on child spans. Those may\n   * still be running and can be ended later.\n   *\n   * Do not return `this`. The Span generally should not be used after it\n   * is ended so chaining is not desired in this context.\n   *\n   * @param endTime - the time to set as Span's end time. If not provided,\n   *     use the current time as the span's end time.\n   */\n  end(endTime?: TimeInput): void;\n  /**\n   * Returns the flag whether this span will be recorded.\n   *\n   * @returns true if this Span is active and recording information like events\n   *     with the `AddEvent` operation and attributes using `setAttributes`.\n   */\n  isRecording(): boolean;\n\n  /**\n   * Sets exception as a span event\n   * @param exception - the exception the only accepted values are string or Error\n   * @param time - the time to set as Span's event time. If not provided,\n   *     use the current time.\n   */\n  recordException(exception: Exception, time?: TimeInput): void;\n\n  /**\n   * Updates the Span name.\n   *\n   * This will override the name provided via {@link Tracer.startSpan}.\n   *\n   * Upon this update, any sampling behavior based on Span name will depend on\n   * the implementation.\n   *\n   * @param name - the Span name.\n   */\n  updateName(name: string): this;\n}\n\n/**\n * Shorthand enum for common traceFlags values inside SpanContext\n */\nexport const enum TraceFlags {\n  /** No flag set. */\n  NONE = 0x0,\n  /** Caller is collecting trace information. */\n  SAMPLED = 0x1\n}\n\n/**\n * A light interface that tries to be structurally compatible with OpenTelemetry\n */\nexport interface SpanContext {\n  /**\n   * UUID of a trace.\n   */\n  traceId: string;\n  /**\n   * UUID of a Span.\n   */\n  spanId: string;\n  /**\n   * https://www.w3.org/TR/trace-context/#trace-flags\n   */\n  traceFlags: number;\n  /**\n   * Tracing-system-specific info to propagate.\n   *\n   * The tracestate field value is a `list` as defined below. The `list` is a\n   * series of `list-members` separated by commas `,`, and a list-member is a\n   * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\n   * surrounding `list-members` are ignored. There can be a maximum of 32\n   * `list-members` in a `list`.\n   * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\n   *\n   * Examples:\n   *     Single tracing system (generic format):\n   *         tracestate: rojo=00f067aa0ba902b7\n   *     Multiple tracing systems (with different formatting):\n   *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\n   */\n  traceState?: TraceState;\n}\n\n/**\n * Used to specify a span that is linked to another.\n */\nexport interface Link {\n  /** The {@link SpanContext} of a linked span. */\n  context: SpanContext;\n\n  /** A set of {@link SpanAttributes} on the link. */\n  attributes?: SpanAttributes;\n}\n\n/**\n * Attributes for a Span.\n */\nexport interface SpanAttributes {\n  /**\n   * Attributes for a Span.\n   */\n  [attributeKey: string]: SpanAttributeValue | undefined;\n}\n/**\n * Attribute values may be any non-nullish primitive value except an object.\n *\n * null or undefined attribute values are invalid and will result in undefined behavior.\n */\nexport declare type SpanAttributeValue =\n  | string\n  | number\n  | boolean\n  | Array<null | undefined | string>\n  | Array<null | undefined | number>\n  | Array<null | undefined | boolean>;\n\n/**\n * An interface that enables manual propagation of Spans\n */\nexport interface SpanOptions {\n  /**\n   * Attributes to set on the Span\n   */\n  attributes?: SpanAttributes;\n\n  /** {@link Link}s span to other spans */\n  links?: Link[];\n\n  /**\n   * The type of Span. Default to SpanKind.INTERNAL\n   */\n  kind?: SpanKind;\n\n  /**\n   * A manually specified start time for the created `Span` object.\n   */\n  startTime?: TimeInput;\n}\n\n/**\n * Tracing options to set on an operation.\n */\nexport interface OperationTracingOptions {\n  /**\n   * OpenTelemetry SpanOptions used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  /**\n   * OpenTelemetry context to use for created Spans.\n   */\n  tracingContext?: Context;\n}\n\n/**\n * OpenTelemetry compatible interface for Context\n */\nexport interface Context {\n  /**\n   * Get a value from the context.\n   *\n   * @param key - key which identifies a context value\n   */\n  getValue(key: symbol): unknown;\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key - context key for which to set the value\n   * @param value - value to set for the given key\n   */\n  setValue(key: symbol, value: unknown): Context;\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key - context key for which to clear a value\n   */\n  deleteValue(key: symbol): Context;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getTracer } from \"../src/tracerProxy\";\nimport {\n  OperationTracingOptions,\n  Span,\n  SpanOptions,\n  SpanKind,\n  setSpan,\n  context as otContext\n} from \"./interfaces\";\n\n/**\n * Arguments for `createSpanFunction` that allow you to specify the\n * prefix for each created span as well as the `az.namespace` attribute.\n *\n * @hidden\n */\nexport interface CreateSpanFunctionArgs {\n  /**\n   * Package name prefix.\n   *\n   * NOTE: if this is empty no prefix will be applied to created Span names.\n   */\n  packagePrefix: string;\n  /**\n   * Service namespace\n   *\n   * NOTE: if this is empty no `az.namespace` attribute will be added to created Spans.\n   */\n  namespace: string;\n}\n\n/**\n * Creates a function that can be used to create spans using the global tracer.\n *\n * Usage:\n *\n * ```typescript\n * // once\n * const createSpan = createSpanFunction({ packagePrefix: \"Azure.Data.AppConfiguration\", namespace: \"Microsoft.AppConfiguration\" });\n *\n * // in each operation\n * const span = createSpan(\"deleteConfigurationSetting\", operationOptions);\n *    // code...\n * span.end();\n * ```\n *\n * @hidden\n * @param args - allows configuration of the prefix for each span as well as the az.namespace field.\n */\nexport function createSpanFunction(args: CreateSpanFunctionArgs) {\n  return function<T extends { tracingOptions?: OperationTracingOptions }>(\n    operationName: string,\n    operationOptions: T | undefined\n  ): { span: Span; updatedOptions: T } {\n    const tracer = getTracer();\n    const tracingOptions = operationOptions?.tracingOptions || {};\n    const spanOptions: SpanOptions = {\n      kind: SpanKind.INTERNAL,\n      ...tracingOptions.spanOptions\n    };\n\n    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;\n    const span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);\n\n    if (args.namespace) {\n      span.setAttribute(\"az.namespace\", args.namespace);\n    }\n\n    let newSpanOptions = tracingOptions.spanOptions || {};\n\n    if (span.isRecording() && args.namespace) {\n      newSpanOptions = {\n        ...tracingOptions.spanOptions,\n        attributes: {\n          ...spanOptions.attributes,\n          \"az.namespace\": args.namespace\n        }\n      };\n    }\n\n    const newTracingOptions: Required<OperationTracingOptions> = {\n      ...tracingOptions,\n      spanOptions: newSpanOptions,\n      tracingContext: setSpan(tracingOptions.tracingContext || otContext.active(), span)\n    };\n\n    const newOperationOptions = {\n      ...operationOptions,\n      tracingOptions: newTracingOptions\n    } as T & { tracingOptions: Required<OperationTracingOptions> };\n\n    return {\n      span,\n      updatedOptions: newOperationOptions\n    };\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createSpanFunction } from \"@azure/core-tracing\";\n\n/**\n * Creates a span using the global tracer.\n * @internal\n */\nexport const createSpan = createSpanFunction({\n  packagePrefix: \"Azure.CognitiveServices.TextAnalytics\",\n  namespace: \"Microsoft.CognitiveServices\"\n});\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  PipelineResponse,\n  PipelineRequest,\n  SendRequest,\n  PipelinePolicy\n} from \"@azure/core-rest-pipeline\";\n\nconst API_KEY_HEADER_NAME = \"Ocp-Apim-Subscription-Key\";\n\n/**\n * The programmatic identifier of the textAnalyticsAzureKeyCredentialPolicy.\n */\nexport const textAnalyticsAzureKeyCredentialPolicyName = \"textAnalyticsAzureKeyCredentialPolicy\";\n\n/**\n * Create an HTTP pipeline policy to authenticate a request\n * using an `AzureKeyCredential` for Text Analytics\n * @internal\n */\nexport function textAnalyticsAzureKeyCredentialPolicy(credential: KeyCredential): PipelinePolicy {\n  return {\n    name: textAnalyticsAzureKeyCredentialPolicyName,\n    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      request.headers.set(API_KEY_HEADER_NAME, credential.key);\n      return next(request);\n    }\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The `@azure/logger` configuration for this package.\n * @internal\n */\nexport const logger = createClientLogger(\"core-lro\");\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PollOperation, PollOperationState } from \"./pollOperation\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { CancelOnProgress } from \"../poller/models\";\nimport { PollerLike } from \"./models\";\n\n/**\n * PollProgressCallback<TState> is the type of the callback functions sent to onProgress.\n * These functions will receive a TState that is defined by your implementation of\n * the Poller class.\n */\nexport type PollProgressCallback<TState> = (state: TState) => void;\n\n/**\n * When a poller is manually stopped through the `stopPolling` method,\n * the poller will be rejected with an instance of the PollerStoppedError.\n */\nexport class PollerStoppedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PollerStoppedError\";\n    Object.setPrototypeOf(this, PollerStoppedError.prototype);\n  }\n}\n\n/**\n * When the operation is cancelled, the poller will be rejected with an instance\n * of the PollerCancelledError.\n */\nexport class PollerCancelledError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PollerCancelledError\";\n    Object.setPrototypeOf(this, PollerCancelledError.prototype);\n  }\n}\n\n/**\n * A class that represents the definition of a program that polls through consecutive requests\n * until it reaches a state of completion.\n *\n * A poller can be executed manually, by polling request by request by calling to the `poll()` method repeatedly, until its operation is completed.\n * It also provides a way to wait until the operation completes, by calling `pollUntilDone()` and waiting until the operation finishes.\n * Pollers can also request the cancellation of the ongoing process to whom is providing the underlying long running operation.\n *\n * ```ts\n * const poller = new MyPoller();\n *\n * // Polling just once:\n * await poller.poll();\n *\n * // We can try to cancel the request here, by calling:\n * //\n * //     await poller.cancelOperation();\n * //\n *\n * // Getting the final result:\n * const result = await poller.pollUntilDone();\n * ```\n *\n * The Poller is defined by two types, a type representing the state of the poller, which\n * must include a basic set of properties from `PollOperationState<TResult>`,\n * and a return type defined by `TResult`, which can be anything.\n *\n * The Poller class implements the `PollerLike` interface, which allows poller implementations to avoid having\n * to export the Poller's class directly, and instead only export the already instantiated poller with the PollerLike type.\n *\n * ```ts\n * class Client {\n *   public async makePoller: PollerLike<MyOperationState, MyResult> {\n *     const poller = new MyPoller({});\n *     // It might be preferred to return the poller after the first request is made,\n *     // so that some information can be obtained right away.\n *     await poller.poll();\n *     return poller;\n *   }\n * }\n *\n * const poller: PollerLike<MyOperationState, MyResult> = myClient.makePoller();\n * ```\n *\n * A poller can be created through its constructor, then it can be polled until it's completed.\n * At any point in time, the state of the poller can be obtained without delay through the getOperationState method.\n * At any point in time, the intermediate forms of the result type can be requested without delay.\n * Once the underlying operation is marked as completed, the poller will stop and the final value will be returned.\n *\n * ```ts\n * const poller = myClient.makePoller();\n * const state: MyOperationState = poller.getOperationState();\n *\n * // The intermediate result can be obtained at any time.\n * const result: MyResult | undefined = poller.getResult();\n *\n * // The final result can only be obtained after the poller finishes.\n * const result: MyResult = await poller.pollUntilDone();\n * ```\n *\n */\n// eslint-disable-next-line no-use-before-define\nexport abstract class Poller<TState extends PollOperationState<TResult>, TResult>\n  implements PollerLike<TState, TResult>\n{\n  /** controls whether to throw an error if the operation failed or was canceled. */\n  protected resolveOnUnsuccessful: boolean = false;\n  private stopped: boolean = true;\n  private resolve?: (value: TResult) => void;\n  private reject?: (error: PollerStoppedError | PollerCancelledError | Error) => void;\n  private pollOncePromise?: Promise<void>;\n  private cancelPromise?: Promise<void>;\n  private promise: Promise<TResult>;\n  private pollProgressCallbacks: PollProgressCallback<TState>[] = [];\n\n  /**\n   * The poller's operation is available in full to any of the methods of the Poller class\n   * and any class extending the Poller class.\n   */\n  protected operation: PollOperation<TState, TResult>;\n\n  /**\n   * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.\n   *\n   * When writing an implementation of a Poller, this implementation needs to deal with the initialization\n   * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's\n   * operation has already been defined, at least its basic properties. The code below shows how to approach\n   * the definition of the constructor of a new custom poller.\n   *\n   * ```ts\n   * export class MyPoller extends Poller<MyOperationState, string> {\n   *   constructor({\n   *     // Anything you might need outside of the basics\n   *   }) {\n   *     let state: MyOperationState = {\n   *       privateProperty: private,\n   *       publicProperty: public,\n   *     };\n   *\n   *     const operation = {\n   *       state,\n   *       update,\n   *       cancel,\n   *       toString\n   *     }\n   *\n   *     // Sending the operation to the parent's constructor.\n   *     super(operation);\n   *\n   *     // You can assign more local properties here.\n   *   }\n   * }\n   * ```\n   *\n   * Inside of this constructor, a new promise is created. This will be used to\n   * tell the user when the poller finishes (see `pollUntilDone()`). The promise's\n   * resolve and reject methods are also used internally to control when to resolve\n   * or reject anyone waiting for the poller to finish.\n   *\n   * The constructor of a custom implementation of a poller is where any serialized version of\n   * a previous poller's operation should be deserialized into the operation sent to the\n   * base constructor. For example:\n   *\n   * ```ts\n   * export class MyPoller extends Poller<MyOperationState, string> {\n   *   constructor(\n   *     baseOperation: string | undefined\n   *   ) {\n   *     let state: MyOperationState = {};\n   *     if (baseOperation) {\n   *       state = {\n   *         ...JSON.parse(baseOperation).state,\n   *         ...state\n   *       };\n   *     }\n   *     const operation = {\n   *       state,\n   *       // ...\n   *     }\n   *     super(operation);\n   *   }\n   * }\n   * ```\n   *\n   * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.\n   */\n  constructor(operation: PollOperation<TState, TResult>) {\n    this.operation = operation;\n    this.promise = new Promise<TResult>(\n      (\n        resolve: (result: TResult) => void,\n        reject: (error: PollerStoppedError | PollerCancelledError | Error) => void\n      ) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      }\n    );\n    // This prevents the UnhandledPromiseRejectionWarning in node.js from being thrown.\n    // The above warning would get thrown if `poller.poll` is called, it returns an error,\n    // and pullUntilDone did not have a .catch or await try/catch on it's return value.\n    this.promise.catch(() => {\n      /* intentionally blank */\n    });\n  }\n\n  /**\n   * Defines how much to wait between each poll request.\n   * This has to be implemented by your custom poller.\n   *\n   * \\@azure/core-util has a simple implementation of a delay function that waits as many milliseconds as specified.\n   * This can be used as follows:\n   *\n   * ```ts\n   * import { delay } from \"@azure/core-util\";\n   *\n   * export class MyPoller extends Poller<MyOperationState, string> {\n   *   // The other necessary definitions.\n   *\n   *   async delay(): Promise<void> {\n   *     const milliseconds = 1000;\n   *     return delay(milliseconds);\n   *   }\n   * }\n   * ```\n   *\n   */\n  protected abstract delay(): Promise<void>;\n\n  /**\n   * Starts a loop that will break only if the poller is done\n   * or if the poller is stopped.\n   */\n  private async startPolling(pollOptions: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (this.stopped) {\n      this.stopped = false;\n    }\n    while (!this.isStopped() && !this.isDone()) {\n      await this.poll(pollOptions);\n      await this.delay();\n    }\n  }\n\n  /**\n   * pollOnce does one polling, by calling to the update method of the underlying\n   * poll operation to make any relevant change effective.\n   *\n   * It only optionally receives an object with an abortSignal property, from \\@azure/abort-controller's AbortSignalLike.\n   *\n   * @param options - Optional properties passed to the operation's update method.\n   */\n  private async pollOnce(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (!this.isDone()) {\n      this.operation = await this.operation.update({\n        abortSignal: options.abortSignal,\n        fireProgress: this.fireProgress.bind(this),\n      });\n    }\n    this.processUpdatedState();\n  }\n\n  /**\n   * fireProgress calls the functions passed in via onProgress the method of the poller.\n   *\n   * It loops over all of the callbacks received from onProgress, and executes them, sending them\n   * the current operation state.\n   *\n   * @param state - The current operation state.\n   */\n  private fireProgress(state: TState): void {\n    for (const callback of this.pollProgressCallbacks) {\n      callback(state);\n    }\n  }\n\n  /**\n   * Invokes the underlying operation's cancel method.\n   */\n  private async cancelOnce(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    this.operation = await this.operation.cancel(options);\n  }\n\n  /**\n   * Returns a promise that will resolve once a single polling request finishes.\n   * It does this by calling the update method of the Poller's operation.\n   *\n   * It only optionally receives an object with an abortSignal property, from \\@azure/abort-controller's AbortSignalLike.\n   *\n   * @param options - Optional properties passed to the operation's update method.\n   */\n  public poll(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (!this.pollOncePromise) {\n      this.pollOncePromise = this.pollOnce(options);\n      const clearPollOncePromise = (): void => {\n        this.pollOncePromise = undefined;\n      };\n      this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);\n    }\n    return this.pollOncePromise;\n  }\n\n  private processUpdatedState(): void {\n    if (this.operation.state.error) {\n      this.stopped = true;\n      if (!this.resolveOnUnsuccessful) {\n        this.reject!(this.operation.state.error);\n        throw this.operation.state.error;\n      }\n    }\n    if (this.operation.state.isCancelled) {\n      this.stopped = true;\n      if (!this.resolveOnUnsuccessful) {\n        const error = new PollerCancelledError(\"Operation was canceled\");\n        this.reject!(error);\n        throw error;\n      }\n    }\n    if (this.isDone() && this.resolve) {\n      // If the poller has finished polling, this means we now have a result.\n      // However, it can be the case that TResult is instantiated to void, so\n      // we are not expecting a result anyway. To assert that we might not\n      // have a result eventually after finishing polling, we cast the result\n      // to TResult.\n      this.resolve(this.getResult() as TResult);\n    }\n  }\n\n  /**\n   * Returns a promise that will resolve once the underlying operation is completed.\n   */\n  public async pollUntilDone(\n    pollOptions: { abortSignal?: AbortSignalLike } = {}\n  ): Promise<TResult> {\n    if (this.stopped) {\n      this.startPolling(pollOptions).catch(this.reject);\n    }\n    // This is needed because the state could have been updated by\n    // `cancelOperation`, e.g. the operation is canceled or an error occurred.\n    this.processUpdatedState();\n    return this.promise;\n  }\n\n  /**\n   * Invokes the provided callback after each polling is completed,\n   * sending the current state of the poller's operation.\n   *\n   * It returns a method that can be used to stop receiving updates on the given callback function.\n   */\n  public onProgress(callback: (state: TState) => void): CancelOnProgress {\n    this.pollProgressCallbacks.push(callback);\n    return (): void => {\n      this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);\n    };\n  }\n\n  /**\n   * Returns true if the poller has finished polling.\n   */\n  public isDone(): boolean {\n    const state: PollOperationState<TResult> = this.operation.state;\n    return Boolean(state.isCompleted || state.isCancelled || state.error);\n  }\n\n  /**\n   * Stops the poller from continuing to poll.\n   */\n  public stopPolling(): void {\n    if (!this.stopped) {\n      this.stopped = true;\n      if (this.reject) {\n        this.reject(new PollerStoppedError(\"This poller is already stopped\"));\n      }\n    }\n  }\n\n  /**\n   * Returns true if the poller is stopped.\n   */\n  public isStopped(): boolean {\n    return this.stopped;\n  }\n\n  /**\n   * Attempts to cancel the underlying operation.\n   *\n   * It only optionally receives an object with an abortSignal property, from \\@azure/abort-controller's AbortSignalLike.\n   *\n   * If it's called again before it finishes, it will throw an error.\n   *\n   * @param options - Optional properties passed to the operation's update method.\n   */\n  public cancelOperation(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (!this.cancelPromise) {\n      this.cancelPromise = this.cancelOnce(options);\n    } else if (options.abortSignal) {\n      throw new Error(\"A cancel request is currently pending\");\n    }\n    return this.cancelPromise;\n  }\n\n  /**\n   * Returns the state of the operation.\n   *\n   * Even though TState will be the same type inside any of the methods of any extension of the Poller class,\n   * implementations of the pollers can customize what's shared with the public by writing their own\n   * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller\n   * and a public type representing a safe to share subset of the properties of the internal state.\n   * Their definition of getOperationState can then return their public type.\n   *\n   * Example:\n   *\n   * ```ts\n   * // Let's say we have our poller's operation state defined as:\n   * interface MyOperationState extends PollOperationState<ResultType> {\n   *   privateProperty?: string;\n   *   publicProperty?: string;\n   * }\n   *\n   * // To allow us to have a true separation of public and private state, we have to define another interface:\n   * interface PublicState extends PollOperationState<ResultType> {\n   *   publicProperty?: string;\n   * }\n   *\n   * // Then, we define our Poller as follows:\n   * export class MyPoller extends Poller<MyOperationState, ResultType> {\n   *   // ... More content is needed here ...\n   *\n   *   public getOperationState(): PublicState {\n   *     const state: PublicState = this.operation.state;\n   *     return {\n   *       // Properties from PollOperationState<TResult>\n   *       isStarted: state.isStarted,\n   *       isCompleted: state.isCompleted,\n   *       isCancelled: state.isCancelled,\n   *       error: state.error,\n   *       result: state.result,\n   *\n   *       // The only other property needed by PublicState.\n   *       publicProperty: state.publicProperty\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * You can see this in the tests of this repository, go to the file:\n   * `../test/utils/testPoller.ts`\n   * and look for the getOperationState implementation.\n   */\n  public getOperationState(): TState {\n    return this.operation.state;\n  }\n\n  /**\n   * Returns the result value of the operation,\n   * regardless of the state of the poller.\n   * It can return undefined or an incomplete form of the final TResult value\n   * depending on the implementation.\n   */\n  public getResult(): TResult | undefined {\n    const state: PollOperationState<TResult> = this.operation.state;\n    return state.result;\n  }\n\n  /**\n   * Returns a serialized version of the poller's operation\n   * by invoking the operation's toString method.\n   */\n  public toString(): string {\n    return this.operation.toString();\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { GeneratedClient } from \"../generated/generatedClient\";\nimport { State, TextDocumentInput } from \"../generated/models\";\nimport { delay } from \"../util\";\n\n/**\n * Common parameters to a Poller.\n * @internal\n */\nexport interface AnalysisPollerOptions {\n  readonly client: GeneratedClient;\n  readonly documents: TextDocumentInput[];\n  updateIntervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * Metadata information for an analysis poller operation.\n */\nexport interface OperationMetadata {\n  /**\n   * The date and time the operation was created.\n   */\n  createdOn: Date;\n  /**\n   * The date and time when the operation results will expire on the server.\n   */\n  expiresOn?: Date;\n  /**\n   * The operation id.\n   */\n  operationId: string;\n  /**\n   * The time the operation status was last updated.\n   */\n  lastModifiedOn: Date;\n  /**\n   * The current status of the operation.\n   */\n  status: State;\n}\n\n/**\n * An interface representing the state of an analysis poller operation.\n */\nexport interface AnalysisPollOperationState<TResult>\n  extends PollOperationState<TResult>,\n    OperationMetadata {}\n\n/**\n * Common properties and methods of analysis Pollers.\n * @internal\n */\nexport abstract class AnalysisPoller<TState, TResult> extends Poller<TState, TResult> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   */\n  public updateIntervalInMs: number = 2000;\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   */\n  async delay(): Promise<void> {\n    return delay(this.updateIntervalInMs);\n  }\n}\n\n/**\n * Common properties and methods of polling operations.\n * @internal\n */\nexport abstract class AnalysisPollOperation<TState, TResult>\n  implements PollOperation<TState, TResult> {\n  constructor(public state: TState) {}\n\n  /**\n   * Meant to reach to the service and update the Poller operation.\n   * @param options - The optional parameters, which is only an abortSignal from \\@azure/abort-controller\n   */\n  public abstract update(): Promise<PollOperation<TState, TResult>>;\n\n  /**\n   * Meant to reach to the service and cancel the Poller operation.\n   * @param options - The optional parameters, which is only an abortSignal from \\@azure/abort-controller\n   */\n  public abstract cancel(): Promise<PollOperation<TState, TResult>>;\n\n  /**\n   * Serializes the Poller operation.\n   */\n  public toString(): string {\n    return JSON.stringify({\n      state: this.state\n    });\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport {\n  DocumentHealthcareEntities,\n  Entity,\n  HealthcareRelation,\n  TextDocumentBatchStatistics,\n  HealthcareEntity as GeneratedHealthcareEntity,\n  TextAnalyticsError,\n  HealthcareAssertion,\n  RelationType,\n  HealthcareRelationEntity,\n  HealthcareEntityCategory\n} from \"./generated/models\";\nimport {\n  makeTextAnalyticsErrorResult,\n  makeTextAnalyticsSuccessResult,\n  TextAnalyticsErrorResult,\n  TextAnalyticsSuccessResult\n} from \"./textAnalyticsResult\";\nimport { parseHealthcareEntityIndex } from \"./util\";\n\n/**\n * A type representing a reference for the healthcare entity into a specific\n * entity catalog.\n */\nexport interface EntityDataSource {\n  /**\n   * Entity Catalog. Examples include: UMLS, CHV, MSH, etc.\n   */\n  name: string;\n  /**\n   * Entity id in the given source catalog.\n   */\n  entityId: string;\n}\n\n/**\n * A healthcare entity represented as a node in a directed graph where the edges are\n * a particular type of relationship between the source and target nodes.\n */\nexport interface HealthcareEntity extends Entity {\n  /**\n   * Normalized name for the entity. For example, the normalized text for \"histologically\" is \"histologic\".\n   */\n  normalizedText?: string;\n  /**\n   * Whether the entity is negated.\n   */\n  assertion?: HealthcareAssertion;\n  /**\n   * Entity references in known data sources.\n   */\n  dataSources: EntityDataSource[];\n  /**\n   * Defines values for HealthcareEntityCategory.\n   * {@link KnownHealthcareEntityCategory} can be used interchangeably with HealthcareEntityCategory,\n   *  this enum contains the known values that the service supports.\n   * ### Known values supported by the service\n   * **BODY_STRUCTURE**\n   * **AGE**\n   * **GENDER**\n   * **EXAMINATION_NAME**\n   * **DATE**\n   * **DIRECTION**\n   * **FREQUENCY**\n   * **MEASUREMENT_VALUE**\n   * **MEASUREMENT_UNIT**\n   * **RELATIONAL_OPERATOR**\n   * **TIME**\n   * **GENE_OR_PROTEIN**\n   * **VARIANT**\n   * **ADMINISTRATIVE_EVENT**\n   * **CARE_ENVIRONMENT**\n   * **HEALTHCARE_PROFESSION**\n   * **DIAGNOSIS**\n   * **SYMPTOM_OR_SIGN**\n   * **CONDITION_QUALIFIER**\n   * **MEDICATION_CLASS**\n   * **MEDICATION_NAME**\n   * **DOSAGE**\n   * **MEDICATION_FORM**\n   * **MEDICATION_ROUTE**\n   * **FAMILY_RELATION**\n   * **TREATMENT_NAME**\n   */\n  category: HealthcareEntityCategory;\n}\n\n/**\n * The type of different roles a healthcare entity can play in a relation.\n */\nexport type HealthcareEntityRelationRoleType = string;\n\n/**\n * A healthcare entity that plays a specific role in a relation.\n */\nexport interface HealthcareEntityRelationRole {\n  /**\n   * A healthcare entity\n   */\n  entity: HealthcareEntity;\n  /**\n   * The role of the healthcare entity in a particular relation.\n   */\n  name: HealthcareEntityRelationRoleType;\n}\n\n/**\n * A relationship between two or more healthcare entities.\n */\nexport interface HealthcareEntityRelation {\n  /**\n   * The type of the healthcare relation.\n   */\n  relationType: RelationType;\n  /**\n   * The list of healthcare entities and their roles in the healthcare relation.\n   */\n  roles: HealthcareEntityRelationRole[];\n}\n\n/**\n * The results of a successful healthcare operation for a single document.\n */\nexport interface AnalyzeHealthcareEntitiesSuccessResult extends TextAnalyticsSuccessResult {\n  /**\n   * Healthcare entities.\n   */\n  entities: HealthcareEntity[];\n  /**\n   * Relations between healthcare entities.\n   */\n  entityRelations: HealthcareEntityRelation[];\n}\n\n/**\n * An error result from the healthcare operation on a single document.\n */\nexport type AnalyzeHealthcareEntitiesErrorResult = TextAnalyticsErrorResult;\n\n/**\n * The result of the healthcare operation on a single document.\n */\nexport type AnalyzeHealthcareEntitiesResult =\n  | AnalyzeHealthcareEntitiesSuccessResult\n  | AnalyzeHealthcareEntitiesErrorResult;\n\n/**\n * Array of {@link AnalyzeHealthcareEntitiesResult}\n */\nexport interface AnalyzeHealthcareEntitiesResultArray\n  extends Array<AnalyzeHealthcareEntitiesResult> {}\n\n/**\n * The results of a healthcare operation represented as a paged iterator that can\n * either iterate over the results on a document-by-document basis or, by\n * byPage(), can iterate over pages of documents.\n */\nexport type PagedAsyncIterableAnalyzeHealthcareEntitiesResult = PagedAsyncIterableIterator<\n  AnalyzeHealthcareEntitiesResult,\n  AnalyzeHealthcareEntitiesResultArray\n>;\n\n/**\n * The results of a healthcare operation represented as a paged iterator that can\n * either iterate over the results on a document-by-document basis or, by\n * byPage(), can iterate over pages of documents.\n */\nexport interface PagedAnalyzeHealthcareEntitiesResult\n  extends PagedAsyncIterableAnalyzeHealthcareEntitiesResult {\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion: string;\n}\n\n/**\n * Creates a user-friendly healthcare entity represented as a node in a graph\n * @param entity - the healthcare entity returned by the service\n * @internal\n */\nfunction makeHealthcareEntitiesWithoutNeighbors(\n  entity: GeneratedHealthcareEntity\n): HealthcareEntity {\n  const {\n    category,\n    confidenceScore,\n    assertion,\n    offset,\n    text,\n    links,\n    subcategory,\n    length,\n    name\n  } = entity;\n  return {\n    category,\n    confidenceScore,\n    assertion,\n    offset,\n    length,\n    text,\n    normalizedText: name,\n    subCategory: subcategory,\n    dataSources:\n      links?.map(({ dataSource, id }): EntityDataSource => ({ name: dataSource, entityId: id })) ??\n      []\n  };\n}\n\n/**\n * @internal\n */\nfunction makeHealthcareRelations(\n  entities: HealthcareEntity[],\n  relations: HealthcareRelation[]\n): HealthcareEntityRelation[] {\n  return relations.map(\n    (relation: HealthcareRelation): HealthcareEntityRelation => ({\n      relationType: relation.relationType,\n      roles: relation.entities.map(\n        (role: HealthcareRelationEntity): HealthcareEntityRelationRole => ({\n          entity: entities[parseHealthcareEntityIndex(role.ref)],\n          name: role.role\n        })\n      )\n    })\n  );\n}\n\n/**\n * Creates a healthcare entity in the convenience layer from the one sent by the service.\n * @param document - incoming results sent by the service for a particular document\n * @internal\n */\nexport function makeHealthcareEntitiesResult(\n  document: DocumentHealthcareEntities\n): AnalyzeHealthcareEntitiesSuccessResult {\n  const { id, entities, relations, warnings, statistics } = document;\n  const newEntities = entities.map(makeHealthcareEntitiesWithoutNeighbors);\n  return {\n    ...makeTextAnalyticsSuccessResult(id, warnings, statistics),\n    entities: newEntities,\n    entityRelations: makeHealthcareRelations(newEntities, relations)\n  };\n}\n\n/**\n * @internal\n */\nexport function makeHealthcareEntitiesErrorResult(\n  id: string,\n  error: TextAnalyticsError\n): AnalyzeHealthcareEntitiesErrorResult {\n  return makeTextAnalyticsErrorResult(id, error);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-client\";\n\nimport {\n  GeneratedClientHealthResponse as BeginAnalyzeHealthcareResponse,\n  GeneratedClientHealthStatusOptionalParams as HealthcareJobStatusOptions,\n  HealthcareJobState,\n  State,\n  TextDocumentBatchStatistics,\n  TextDocumentInput\n} from \"../../generated/models\";\nimport {\n  AnalyzeHealthcareEntitiesResult,\n  AnalyzeHealthcareEntitiesResultArray,\n  PagedAsyncIterableAnalyzeHealthcareEntitiesResult,\n  PagedAnalyzeHealthcareEntitiesResult,\n  makeHealthcareEntitiesResult,\n  makeHealthcareEntitiesErrorResult\n} from \"../../analyzeHealthcareEntitiesResult\";\nimport { PageSettings } from \"@azure/core-paging\";\nimport {\n  addStrEncodingParam,\n  getOperationId,\n  handleInvalidDocumentBatch,\n  nextLinkToTopAndSkip,\n  StringIndexType\n} from \"../../util\";\nimport {\n  AnalysisPollOperation,\n  AnalysisPollOperationState,\n  OperationMetadata as AnalyzeHealthcareEntitiesOperationMetadata\n} from \"../poller\";\nimport { GeneratedClient as Client } from \"../../generated\";\nimport { processAndCombineSuccessfulAndErroneousDocuments } from \"../../textAnalyticsResult\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { createSpan } from \"../../tracing\";\nimport { TextAnalyticsOperationOptions } from \"../../textAnalyticsOperationOptions\";\nexport { State };\n\n/**\n * @internal\n */\ninterface AnalyzeHealthcareEntitiesResultWithPagination {\n  result: AnalyzeHealthcareEntitiesResultArray;\n  top?: number;\n  skip?: number;\n}\n\n/**\n * @internal\n */\ninterface HealthcareJobStatus {\n  done: boolean;\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  /**\n   * The version of the text analytics model used by this operation on this\n   * batch of input documents.\n   */\n  modelVersion?: string;\n  operationMetdata: Omit<AnalyzeHealthcareEntitiesOperationMetadata, \"operationId\">;\n}\n\n/**\n * @internal\n */\ninterface BeginAnalyzeHealthcareInternalOptions extends OperationOptions {\n  /**\n   * This value indicates which model will be used for scoring. If a model-version is\n   * not specified, the API should default to the latest, non-preview version.\n   * For supported model versions, see operation-specific documentation, for example:\n   * https://docs.microsoft.com/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-sentiment-analysis#model-versioning\n   */\n  modelVersion?: string;\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * If set to false, you opt-in to have your text input logged for troubleshooting. By default, Text Analytics\n   * will not log your input text for healthcare entities analysis. Setting this parameter to false,\n   * enables input logging.\n   */\n  loggingOptOut?: boolean;\n}\n\n/**\n * Options for the begin analyze healthcare entities operation.\n */\nexport interface BeginAnalyzeHealthcareEntitiesOptions extends TextAnalyticsOperationOptions {\n  /**\n   * Delay to wait until next poll, in milliseconds.\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * Delay to wait until next poll, in milliseconds.\n   */\n  updateIntervalInMs?: number;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n}\n\n/**\n * The state of the begin analyze healthcare polling operation.\n */\nexport interface AnalyzeHealthcareOperationState\n  extends AnalysisPollOperationState<PagedAnalyzeHealthcareEntitiesResult> {}\n\n/**\n * @internal\n */\nfunction getMetaInfoFromResponse(\n  response: HealthcareJobState\n): Omit<AnalyzeHealthcareEntitiesOperationMetadata, \"operationId\"> {\n  return {\n    createdOn: response.createdDateTime,\n    lastModifiedOn: response.lastUpdateDateTime,\n    expiresOn: response.expirationDateTime,\n    status: response.status\n  };\n}\n\n/**\n * Class that represents a poller that waits for the healthcare results.\n * @internal\n */\nexport class BeginAnalyzeHealthcarePollerOperation extends AnalysisPollOperation<\n  AnalyzeHealthcareOperationState,\n  PagedAnalyzeHealthcareEntitiesResult\n> {\n  constructor(\n    public state: AnalyzeHealthcareOperationState,\n    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n    private client: Client,\n    private documents: TextDocumentInput[],\n    private options: BeginAnalyzeHealthcareEntitiesOptions = {}\n  ) {\n    super(state);\n  }\n\n  /**\n   * should be called only after all the status of the healthcare operations became\n   * \"succeeded\" and it returns an iterator for the results and provides a\n   * byPage method to return the results paged.\n   */\n  private listHealthcareEntitiesByPage(\n    operationId: string,\n    options: HealthcareJobStatusOptions = {}\n  ): PagedAsyncIterableAnalyzeHealthcareEntitiesResult {\n    const iter = this._listHealthcareEntities(operationId, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        const pageOptions = { ...options, top: settings?.maxPageSize };\n        return this._listHealthcareEntitiesPaged(operationId, pageOptions);\n      }\n    };\n  }\n\n  /**\n   * returns an iterator to the results of a healthcare operation.\n   */\n  private async *_listHealthcareEntities(\n    operationId: string,\n    options?: HealthcareJobStatusOptions\n  ): AsyncIterableIterator<AnalyzeHealthcareEntitiesResult> {\n    for await (const page of this._listHealthcareEntitiesPaged(operationId, options)) {\n      yield* page;\n    }\n  }\n\n  /**\n   * returns an iterator to arrays of the results of a healthcare operation.\n   */\n  private async *_listHealthcareEntitiesPaged(\n    operationId: string,\n    options?: HealthcareJobStatusOptions\n  ): AsyncIterableIterator<AnalyzeHealthcareEntitiesResultArray> {\n    let response = await this._listHealthcareEntitiesSinglePage(operationId, options);\n    yield response.result;\n    while (response.skip) {\n      const optionsWithContinuation: HealthcareJobStatusOptions = {\n        ...options,\n        top: response.top,\n        skip: response.skip\n      };\n      response = await this._listHealthcareEntitiesSinglePage(operationId, optionsWithContinuation);\n      yield response.result;\n    }\n  }\n\n  /**\n   * returns an iterator to arrays of the sorted results of a healthcare operation.\n   */\n  private async _listHealthcareEntitiesSinglePage(\n    operationId: string,\n    options?: HealthcareJobStatusOptions\n  ): Promise<AnalyzeHealthcareEntitiesResultWithPagination> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-_listHealthcareEntitiesSinglePage\",\n      options || {}\n    );\n    try {\n      const response = await this.client.healthStatus(operationId, finalOptions);\n      if (response.results) {\n        const result = processAndCombineSuccessfulAndErroneousDocuments(\n          this.documents,\n          response.results,\n          makeHealthcareEntitiesResult,\n          makeHealthcareEntitiesErrorResult\n        );\n        return response.nextLink\n          ? { result, ...nextLinkToTopAndSkip(response.nextLink) }\n          : { result };\n      } else {\n        throw new Error(\"Healthcare action has succeeded but the there are no results!\");\n      }\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * returns whether the healthcare operation is done and if so returns also\n   * statistics and the model version used.\n   */\n  private async getHealthStatus(\n    operationId: string,\n    options?: HealthcareJobStatusOptions\n  ): Promise<HealthcareJobStatus> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-getHealthStatus\",\n      options || {}\n    );\n    try {\n      const response = await this.client.healthStatus(operationId, finalOptions);\n      switch (response.status) {\n        case \"notStarted\":\n        case \"running\":\n          break;\n        case \"failed\": {\n          const errors = response.errors\n            ?.map((e) => `  code ${e.code}, message: '${e.message}'`)\n            .join(\"\\n\");\n          const message = `Healthcare analysis failed. Error(s): ${errors || \"\"}`;\n          throw new Error(message);\n        }\n        default: {\n          if (response.results) {\n            return {\n              done: true,\n              statistics: response.results.statistics,\n              modelVersion: response.results.modelVersion,\n              operationMetdata: getMetaInfoFromResponse(response)\n            };\n          } else {\n            throw new Error(\"Healthcare action has finished but the there are no results!\");\n          }\n        }\n      }\n      return { done: false, operationMetdata: getMetaInfoFromResponse(response) };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async beginAnalyzeHealthcare(\n    documents: TextDocumentInput[],\n    options?: BeginAnalyzeHealthcareInternalOptions\n  ): Promise<BeginAnalyzeHealthcareResponse> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-beginAnalyzeHealthcare\",\n      addStrEncodingParam(options || {})\n    );\n\n    try {\n      return await this.client.health({ documents: documents }, finalOptions);\n    } catch (e) {\n      const exception = handleInvalidDocumentBatch(e);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: exception.message\n      });\n      throw exception;\n    } finally {\n      span.end();\n    }\n  }\n\n  async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: AnalyzeHealthcareOperationState) => void;\n    } = {}\n  ): Promise<BeginAnalyzeHealthcarePollerOperation> {\n    const state = this.state;\n    const updatedAbortSignal = options.abortSignal;\n    if (!state.isStarted) {\n      state.isStarted = true;\n      const response = await this.beginAnalyzeHealthcare(this.documents, {\n        requestOptions: this.options.requestOptions,\n        tracingOptions: this.options.tracingOptions,\n        abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,\n        modelVersion: this.options.modelVersion,\n        stringIndexType: this.options.stringIndexType,\n        loggingOptOut: this.options.disableServiceLogs\n      });\n      if (!response.operationLocation) {\n        throw new Error(\n          \"Expects a valid 'operationLocation' to retrieve health results but did not find any\"\n        );\n      }\n      state.operationId = getOperationId(response.operationLocation);\n    }\n    const operationStatus = await this.getHealthStatus(state.operationId!, {\n      abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,\n      includeStatistics: this.options.includeStatistics,\n      tracingOptions: this.options.tracingOptions,\n      onResponse: this.options.onResponse,\n      serializerOptions: this.options.serializerOptions\n    });\n\n    state.createdOn = operationStatus.operationMetdata.createdOn;\n    state.expiresOn = operationStatus.operationMetdata.expiresOn;\n    state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;\n    state.status = operationStatus.operationMetdata.status;\n\n    if (!state.isCompleted && operationStatus.done) {\n      const pagedIterator = this.listHealthcareEntitiesByPage(state.operationId!, {\n        abortSignal: this.options.abortSignal,\n        tracingOptions: this.options.tracingOptions\n      });\n      state.result = Object.assign(pagedIterator, {\n        statistics: operationStatus.statistics,\n        modelVersion: operationStatus.modelVersion!\n      });\n      state.isCompleted = true;\n    }\n    if (typeof options.fireProgress === \"function\") {\n      options.fireProgress(state);\n    }\n    return this;\n  }\n\n  async cancel(): Promise<BeginAnalyzeHealthcarePollerOperation> {\n    const state = this.state;\n    if (state.operationId) {\n      await this.client.cancelHealthJob(state.operationId, {\n        abortSignal: this.options.abortSignal,\n        tracingOptions: this.options.tracingOptions\n      });\n    }\n    state.isCancelled = true;\n    return this;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PollerLike } from \"@azure/core-lro\";\nimport { PagedAnalyzeHealthcareEntitiesResult } from \"../../analyzeHealthcareEntitiesResult\";\nimport { delay } from \"../../util\";\n\nimport { AnalysisPoller, AnalysisPollerOptions } from \"../poller\";\nimport {\n  BeginAnalyzeHealthcarePollerOperation,\n  AnalyzeHealthcareOperationState,\n  BeginAnalyzeHealthcareEntitiesOptions\n} from \"./operation\";\n\n/**\n * @internal\n */\nexport interface HealthcarePollerOptions extends AnalysisPollerOptions {\n  readonly options?: BeginAnalyzeHealthcareEntitiesOptions;\n}\n\n/**\n * Result type of the Health Long-Running-Operation (LRO)\n */\nexport type AnalyzeHealthcareEntitiesPollerLike = PollerLike<\n  AnalyzeHealthcareOperationState,\n  PagedAnalyzeHealthcareEntitiesResult\n>;\n\n/**\n * Class that represents a poller that waits for the healthcare results.\n * @internal\n */\nexport class BeginAnalyzeHealthcarePoller extends AnalysisPoller<\n  AnalyzeHealthcareOperationState,\n  PagedAnalyzeHealthcareEntitiesResult\n> {\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  constructor(inputs: HealthcarePollerOptions) {\n    const { client, documents, options, updateIntervalInMs = 5000, resumeFrom } = inputs;\n\n    let state: AnalyzeHealthcareOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n    const operation = new BeginAnalyzeHealthcarePollerOperation(\n      (state || {}) as any,\n      client,\n      documents,\n      options\n    );\n\n    super(operation);\n\n    this.updateIntervalInMs = updateIntervalInMs;\n  }\n\n  public delay(): Promise<void> {\n    return delay(this.updateIntervalInMs);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport {\n  AnalyzeSentimentResultArray,\n  makeAnalyzeSentimentResultArray\n} from \"./analyzeSentimentResultArray\";\nimport {\n  ExtractKeyPhrasesResultArray,\n  makeExtractKeyPhrasesResultArray\n} from \"./extractKeyPhrasesResultArray\";\nimport { AnalyzeJobState as GeneratedResponse, TextDocumentInput } from \"./generated/models\";\nimport {\n  makeRecognizeCategorizedEntitiesResultArray,\n  RecognizeCategorizedEntitiesResultArray\n} from \"./recognizeCategorizedEntitiesResultArray\";\nimport {\n  makeRecognizeLinkedEntitiesResultArray,\n  RecognizeLinkedEntitiesResultArray\n} from \"./recognizeLinkedEntitiesResultArray\";\nimport {\n  makeRecognizePiiEntitiesResultArray,\n  RecognizePiiEntitiesResultArray\n} from \"./recognizePiiEntitiesResultArray\";\nimport { ErrorCode, intoTextAnalyticsError, TextAnalyticsError } from \"./textAnalyticsResult\";\n\n/**\n * The results of an analyze Actions operation.\n */\nexport interface AnalyzeActionsResult {\n  /**\n   * Array of the results for each categorized entities recognition action.\n   */\n  recognizeEntitiesResults: RecognizeCategorizedEntitiesActionResult[];\n  /**\n   * Array of the results for each Pii entities recognition action.\n   */\n  recognizePiiEntitiesResults: RecognizePiiEntitiesActionResult[];\n  /**\n   * Array of the results for each key phrases extraction action.\n   */\n  extractKeyPhrasesResults: ExtractKeyPhrasesActionResult[];\n  /**\n   * Array of the results for each linked entities recognition action.\n   */\n  recognizeLinkedEntitiesResults: RecognizeLinkedEntitiesActionResult[];\n  /**\n   * Array of the results for each analyze sentiment action.\n   */\n  analyzeSentimentResults: AnalyzeSentimentActionResult[];\n}\n\n/**\n * The state of a succeeded action.\n */\nexport interface TextAnalyticsActionSuccessState {\n  /**\n   * When this action was completed by the service.\n   */\n  readonly completedOn: Date;\n  /**\n   * Discriminant to determine if that this is an error result.\n   */\n  readonly error?: undefined;\n}\n\n/**\n * The error of an analyze batch action.\n */\nexport interface TextAnalyticsActionErrorResult {\n  /**\n   * When this action was completed by the service.\n   */\n  readonly failedOn: Date;\n  /**\n   * The Error for this action result.\n   */\n  readonly error: TextAnalyticsError;\n}\n\n/**\n * The error of a recognize categorized entities action.\n */\nexport type RecognizeCategorizedEntitiesActionErrorResult = TextAnalyticsActionErrorResult;\n\n/**\n * The results of a succeeded recognize categorized entities action.\n */\nexport interface RecognizeCategorizedEntitiesActionSuccessResult\n  extends TextAnalyticsActionSuccessState {\n  /**\n   * Array of the results for each categorized entities recognition action.\n   */\n  results: RecognizeCategorizedEntitiesResultArray;\n}\n\n/**\n * The result of a recognize categorized entities action.\n */\nexport type RecognizeCategorizedEntitiesActionResult =\n  | RecognizeCategorizedEntitiesActionSuccessResult\n  | RecognizeCategorizedEntitiesActionErrorResult;\n\n/**\n * The error of a recognize pii entities action.\n */\nexport type RecognizePiiEntitiesActionErrorResult = TextAnalyticsActionErrorResult;\n\n/**\n * The results of a succeeded recognize pii entities action.\n */\nexport interface RecognizePiiEntitiesActionSuccessResult extends TextAnalyticsActionSuccessState {\n  /**\n   * Array of the results for each pii entities recognition action.\n   */\n  results: RecognizePiiEntitiesResultArray;\n}\n\n/**\n * The result of a recognize pii entities action.\n */\nexport type RecognizePiiEntitiesActionResult =\n  | RecognizePiiEntitiesActionSuccessResult\n  | RecognizePiiEntitiesActionErrorResult;\n\n/**\n * The error of a extract key phrases action.\n */\nexport type ExtractKeyPhrasesActionErrorResult = TextAnalyticsActionErrorResult;\n\n/**\n * The results of a succeeded extract key phrases action.\n */\nexport interface ExtractKeyPhrasesActionSuccessResult extends TextAnalyticsActionSuccessState {\n  /**\n   * Array of the results for each extract key phrases action.\n   */\n  results: ExtractKeyPhrasesResultArray;\n}\n\n/**\n * The result of a extract key phrases action.\n */\nexport type ExtractKeyPhrasesActionResult =\n  | ExtractKeyPhrasesActionSuccessResult\n  | ExtractKeyPhrasesActionErrorResult;\n\n/**\n * The error of a recognize linked entities action.\n */\nexport type RecognizeLinkedEntitiesActionErrorResult = TextAnalyticsActionErrorResult;\n\n/**\n * The results of a succeeded recognize linked entities action.\n */\nexport interface RecognizeLinkedEntitiesActionSuccessResult\n  extends TextAnalyticsActionSuccessState {\n  /**\n   * Array of the results for each linked entities recognition action.\n   */\n  results: RecognizeLinkedEntitiesResultArray;\n}\n\n/**\n * The result of a recognize linked entities action.\n */\nexport type RecognizeLinkedEntitiesActionResult =\n  | RecognizeLinkedEntitiesActionSuccessResult\n  | RecognizeLinkedEntitiesActionErrorResult;\n\n/**\n * The error of an analyze sentiment action.\n */\nexport type AnalyzeSentimentActionErrorResult = TextAnalyticsActionErrorResult;\n\n/**\n * The results of a succeeded analyze sentiment action.\n */\nexport interface AnalyzeSentimentActionSuccessResult extends TextAnalyticsActionSuccessState {\n  /**\n   * Array of the results for each analyze sentiment action.\n   */\n  results: AnalyzeSentimentResultArray;\n}\n\n/**\n * The result of an analyze sentiment action.\n */\nexport type AnalyzeSentimentActionResult =\n  | AnalyzeSentimentActionSuccessResult\n  | AnalyzeSentimentActionErrorResult;\n\n/**\n * The results of an analyze Actions operation represented as a paged iterator that\n * iterates over the results of the requested actions.\n */\nexport type PagedAsyncIterableAnalyzeActionsResult = PagedAsyncIterableIterator<\n  AnalyzeActionsResult,\n  AnalyzeActionsResult\n>;\n\n/**\n * The results of an analyze actions operation represented as a paged iterator that\n * iterates over the results of the requested actions.\n */\nexport interface PagedAnalyzeActionsResult extends PagedAsyncIterableAnalyzeActionsResult {\n  // /**\n  //  * Statistics about the input document batch and how it was processed\n  //  * by the service. This property will have a value when includeStatistics is set to true\n  //  * in the client call.\n  //  */\n  // statistics?: TextDocumentBatchStatistics;\n}\n\n/**\n * The type of different actions supported by the begin analyze actions operation.\n * @internal\n */\ntype TextAnalyticsActionType =\n  | \"RecognizeCategorizedEntities\"\n  | \"RecognizePiiEntities\"\n  | \"ExtractKeyPhrases\"\n  | \"RecognizeLinkedEntities\"\n  | \"AnalyzeSentiment\";\n\n/**\n * The type of an action error with the type of the action that erred and its\n * index in the list of input actions.\n * @internal\n */\ninterface TextAnalyticsActionError {\n  /**\n   * A code describing the kind of error produced\n   */\n  readonly code: ErrorCode;\n  /**\n   * A message from the service explaining the error\n   */\n  readonly message: string;\n  /**\n   * The type of the action that erred\n   */\n  readonly type: TextAnalyticsActionType;\n  /**\n   * The index of the action that erred in the list of input actions\n   */\n  readonly index: number;\n}\n\n/**\n * Converts the service task name (in the JSON pointer in an action error) to an action type name.\n * @param serviceActionType - The task type name the service uses.\n * @returns the action type name that the package uses\n * @internal\n */\nfunction convertTaskTypeToActionType(taskType: string): TextAnalyticsActionType {\n  switch (taskType) {\n    case \"entityRecognitionTasks\": {\n      return \"RecognizeCategorizedEntities\";\n    }\n    case \"entityRecognitionPiiTasks\": {\n      return \"RecognizePiiEntities\";\n    }\n    case \"keyPhraseExtractionTasks\": {\n      return \"ExtractKeyPhrases\";\n    }\n    case \"entityLinkingTasks\": {\n      return \"RecognizeLinkedEntities\";\n    }\n    case \"sentimentAnalysisTasks\": {\n      return \"AnalyzeSentiment\";\n    }\n    default: {\n      throw new Error(`unexpected action type from the service: ${taskType}`);\n    }\n  }\n}\n\n/**\n * Converts a service action error to one with the JSON pointer converted to an action index.\n * @param erredActions - the action error the service sent\n * @returns an action error with an action type and index\n * @internal\n */\nexport function parseActionError(erredActions: TextAnalyticsError): TextAnalyticsActionError {\n  if (erredActions.target) {\n    const regex = new RegExp(\n      /#\\/tasks\\/(entityRecognitionTasks|entityRecognitionPiiTasks|keyPhraseExtractionTasks|entityLinkingTasks|sentimentAnalysisTasks)\\/(\\d+)/\n    );\n    const result = regex.exec(erredActions.target);\n    if (result !== null) {\n      return {\n        code: erredActions.code,\n        message: erredActions.message,\n        index: parseInt(result[2]),\n        type: convertTaskTypeToActionType(result[1])\n      };\n    } else {\n      throw new Error(`Pointer \"${erredActions.target}\" is not a valid action pointer`);\n    }\n  } else {\n    throw new Error(\n      \"expected an error with a target field referencing an action but did not get one\"\n    );\n  }\n}\n\n/**\n * Categorize each action error into a bucket according to its action type.\n * @param erredActions - list of action errors\n * @param recognizeEntitiesActionErrors - a list of recognize entities action errors to be filled from the errors list\n * @param recognizePiiEntitiesActionErrors - a list of recognize pii entities action errors to be filled from the errors list\n * @param extractKeyPhrasesActionErrors - a list of extract key phrases action errors to be filled from the errors list\n * @internal\n */\nfunction categorizeActionErrors(\n  erredActions: TextAnalyticsError[],\n  recognizeEntitiesActionErrors: TextAnalyticsActionError[],\n  recognizePiiEntitiesActionErrors: TextAnalyticsActionError[],\n  extractKeyPhrasesActionErrors: TextAnalyticsActionError[],\n  recognizeLinkedEntitiesActionErrors: TextAnalyticsActionError[],\n  analyzeSentimentActionErrors: TextAnalyticsActionError[]\n): void {\n  for (const error of erredActions) {\n    const actionError = parseActionError(error);\n    switch (actionError.type) {\n      case \"RecognizeCategorizedEntities\": {\n        recognizeEntitiesActionErrors.push(actionError);\n        break;\n      }\n      case \"RecognizePiiEntities\": {\n        recognizePiiEntitiesActionErrors.push(actionError);\n        break;\n      }\n      case \"ExtractKeyPhrases\": {\n        extractKeyPhrasesActionErrors.push(actionError);\n        break;\n      }\n      case \"RecognizeLinkedEntities\": {\n        recognizeLinkedEntitiesActionErrors.push(actionError);\n        break;\n      }\n      case \"AnalyzeSentiment\": {\n        analyzeSentimentActionErrors.push(actionError);\n        break;\n      }\n    }\n  }\n}\n\n/**\n * @internal\n * @param error - the error the service sent for a task\n * @param lastUpdateDateTime - the time when this task failed\n */\nfunction createErredAction(\n  error: TextAnalyticsActionError,\n  lastUpdateDateTime: Date\n): TextAnalyticsActionErrorResult {\n  return { error: intoTextAnalyticsError(error), failedOn: lastUpdateDateTime };\n}\n\ninterface TaskSuccessResult<T> {\n  results?: T;\n  lastUpdateDateTime: Date;\n}\n\ntype ActionResult<TSuccess> =\n  | {\n      results: TSuccess;\n      completedOn: Date;\n    }\n  | TextAnalyticsActionErrorResult;\n\n/**\n * Creates a list of results for any action.\n * @param documents - list of input documents\n * @param makeResultsArray - a function to convert the results of a service response to the SDK's one\n * @param succeededTasks - list of succeeded action results\n * @param erredActions - list of erred actions\n * @internal\n */\nfunction makeActionResult<TTaskResult, TActionResult>(\n  documents: TextDocumentInput[],\n  makeResultsArray: (docs: TextDocumentInput[], x: TTaskResult) => TActionResult,\n  succeededTasks: TaskSuccessResult<TTaskResult>[],\n  erredActions: TextAnalyticsActionError[]\n): ActionResult<TActionResult>[] {\n  let errorIndex = 0;\n  function convertTasksToActions(\n    actions: ActionResult<TActionResult>[],\n    task: TaskSuccessResult<TTaskResult>\n  ): ActionResult<TActionResult>[] {\n    const { results: actionResults, lastUpdateDateTime } = task;\n    if (actionResults !== undefined) {\n      const recognizeEntitiesResults = makeResultsArray(documents, actionResults);\n      return [\n        ...actions,\n        {\n          results: recognizeEntitiesResults,\n          completedOn: lastUpdateDateTime\n        }\n      ];\n    } else {\n      return [...actions, createErredAction(erredActions[errorIndex++], lastUpdateDateTime)];\n    }\n  }\n  return succeededTasks.reduce(convertTasksToActions, []);\n}\n\n/**\n * Creates the user-friendly action results object for the begin analyze actions operation.\n * @param response - the begin analyze actions operation response\n * @param documents - the list of input documents\n * @returns - the user-friendly action results object\n * @internal\n */\nexport function createAnalyzeActionsResult(\n  response: GeneratedResponse,\n  documents: TextDocumentInput[]\n): AnalyzeActionsResult {\n  const recognizeEntitiesActionErrors: TextAnalyticsActionError[] = [];\n  const recognizePiiEntitiesActionErrors: TextAnalyticsActionError[] = [];\n  const extractKeyPhrasesActionErrors: TextAnalyticsActionError[] = [];\n  const recognizeLinkedEntitiesActionErrors: TextAnalyticsActionError[] = [];\n  const analyzeSentimentActionErrors: TextAnalyticsActionError[] = [];\n  categorizeActionErrors(\n    response?.errors ?? [],\n    recognizeEntitiesActionErrors,\n    recognizePiiEntitiesActionErrors,\n    extractKeyPhrasesActionErrors,\n    recognizeLinkedEntitiesActionErrors,\n    analyzeSentimentActionErrors\n  );\n  return {\n    recognizeEntitiesResults: makeActionResult(\n      documents,\n      makeRecognizeCategorizedEntitiesResultArray,\n      response.tasks.entityRecognitionTasks ?? [],\n      recognizeEntitiesActionErrors\n    ),\n    recognizePiiEntitiesResults: makeActionResult(\n      documents,\n      makeRecognizePiiEntitiesResultArray,\n      response.tasks.entityRecognitionPiiTasks ?? [],\n      recognizePiiEntitiesActionErrors\n    ),\n    extractKeyPhrasesResults: makeActionResult(\n      documents,\n      makeExtractKeyPhrasesResultArray,\n      response.tasks.keyPhraseExtractionTasks ?? [],\n      extractKeyPhrasesActionErrors\n    ),\n    recognizeLinkedEntitiesResults: makeActionResult(\n      documents,\n      makeRecognizeLinkedEntitiesResultArray,\n      response.tasks.entityLinkingTasks ?? [],\n      recognizeLinkedEntitiesActionErrors\n    ),\n    analyzeSentimentResults: makeActionResult(\n      documents,\n      makeAnalyzeSentimentResultArray,\n      response.tasks.sentimentAnalysisTasks ?? [],\n      analyzeSentimentActionErrors\n    )\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-client\";\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\nimport {\n  AnalyzeJobState,\n  GeneratedClientAnalyzeResponse as BeginAnalyzeResponse,\n  GeneratedClientAnalyzeStatusOptionalParams as AnalyzeActionsOperationStatusOptions,\n  JobManifestTasks as GeneratedActions,\n  State,\n  TextDocumentBatchStatistics,\n  TextDocumentInput\n} from \"../../generated/models\";\nimport {\n  AnalyzeActionsResult,\n  PagedAsyncIterableAnalyzeActionsResult,\n  PagedAnalyzeActionsResult,\n  createAnalyzeActionsResult\n} from \"../../analyzeActionsResult\";\nimport { PageSettings } from \"@azure/core-paging\";\nimport { getOperationId, handleInvalidDocumentBatch, nextLinkToTopAndSkip } from \"../../util\";\nimport { AnalysisPollOperation, AnalysisPollOperationState, OperationMetadata } from \"../poller\";\nimport { GeneratedClient as Client } from \"../../generated\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { createSpan } from \"../../tracing\";\nimport { logger } from \"../../logger\";\nexport { State };\n\n/**\n * @internal\n */\ninterface AnalyzeResultsWithPagination {\n  result: AnalyzeActionsResult;\n  top?: number;\n  skip?: number;\n}\n\n/**\n * The metadata for beginAnalyzeActions operations.\n */\nexport interface AnalyzeActionsOperationMetadata extends OperationMetadata {\n  /**\n   * Number of successfully completed actions.\n   */\n  actionsSucceededCount: number;\n  /**\n   * Number of failed actions.\n   */\n  actionsFailedCount: number;\n  /**\n   * Number of actions still in progress.\n   */\n  actionsInProgressCount: number;\n  /**\n   * The operation's display name.\n   */\n  displayName?: string;\n}\n\n/**\n * @internal\n */\ninterface AnalyzeActionsOperationStatus {\n  done: boolean;\n  /**\n   * Statistics about the input document batch and how it was processed\n   * by the service. This property will have a value when includeStatistics is set to true\n   * in the client call.\n   */\n  statistics?: TextDocumentBatchStatistics;\n  operationMetdata: Omit<AnalyzeActionsOperationMetadata, \"operationId\">;\n}\n\n/**\n * @internal\n */\ninterface BeginAnalyzeInternalOptions extends OperationOptions {\n  displayName?: string;\n}\n\n/**\n * Options for the begin analyze actions operation.\n */\nexport interface BeginAnalyzeActionsOptions extends OperationOptions {\n  /**\n   * Delay to wait until next poll, in milliseconds.\n   */\n  updateIntervalInMs?: number;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * If set to true, response will contain input and document level statistics.\n   */\n  includeStatistics?: boolean;\n  /**\n   * The operation's display name.\n   */\n  displayName?: string;\n}\n\n/**\n * The state of the begin analyze polling operation.\n */\nexport interface AnalyzeActionsOperationState\n  extends AnalysisPollOperationState<PagedAnalyzeActionsResult>,\n    AnalyzeActionsOperationMetadata {}\n\n/**\n * @internal\n */\nfunction getMetaInfoFromResponse(\n  response: AnalyzeJobState\n): Omit<AnalyzeActionsOperationMetadata, \"operationId\"> {\n  return {\n    createdOn: response.createdDateTime,\n    lastModifiedOn: response.lastUpdateDateTime,\n    expiresOn: response.expirationDateTime,\n    status: response.status,\n    actionsSucceededCount: response.tasks.completed,\n    actionsFailedCount: response.tasks.failed,\n    actionsInProgressCount: response.tasks.inProgress,\n    displayName: response.displayName\n  };\n}\n\n/**\n * Class that represents a poller that waits for results of the analyze\n * operation.\n * @internal\n */\nexport class BeginAnalyzeActionsPollerOperation extends AnalysisPollOperation<\n  AnalyzeActionsOperationState,\n  PagedAnalyzeActionsResult\n> {\n  constructor(\n    public state: AnalyzeActionsOperationState,\n    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n    private client: Client,\n    private documents: TextDocumentInput[],\n    private actions: GeneratedActions,\n    private options: BeginAnalyzeActionsOptions = {}\n  ) {\n    super(state);\n  }\n\n  /**\n   * should be called only after all the status of the analyze actions operations became\n   * \"succeeded\" and it returns an iterator for the results and provides a\n   * byPage method to return the results paged.\n   */\n  private listAnalyzeActionsResults(\n    operationId: string,\n    options: AnalyzeActionsOperationStatusOptions = {}\n  ): PagedAsyncIterableAnalyzeActionsResult {\n    const iter = this._listAnalyzeActionsResultsPaged(operationId, options);\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings?: PageSettings) => {\n        const pageOptions = { ...options, top: settings?.maxPageSize };\n        return this._listAnalyzeActionsResultsPaged(operationId, pageOptions);\n      }\n    };\n  }\n\n  /**\n   * returns an iterator to arrays of the results of an analyze actions operation.\n   */\n  private async *_listAnalyzeActionsResultsPaged(\n    operationId: string,\n    options?: AnalyzeActionsOperationStatusOptions\n  ): AsyncIterableIterator<AnalyzeActionsResult> {\n    let response = await this._listAnalyzeActionsResultsSinglePage(operationId, options);\n    yield response.result;\n    while (response.skip) {\n      const optionsWithContinuation: AnalyzeActionsOperationStatusOptions = {\n        ...options,\n        top: response.top,\n        skip: response.skip\n      };\n      response = await this._listAnalyzeActionsResultsSinglePage(\n        operationId,\n        optionsWithContinuation\n      );\n      yield response.result;\n    }\n  }\n\n  /**\n   * returns an iterator to arrays of the sorted results of an analyze actions operation.\n   */\n  private async _listAnalyzeActionsResultsSinglePage(\n    operationId: string,\n    options?: AnalyzeActionsOperationStatusOptions\n  ): Promise<AnalyzeResultsWithPagination> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-_listAnalyzeActionsResultsSinglePage\",\n      options || {}\n    );\n    try {\n      const response = await this.client.analyzeStatus(operationId, finalOptions);\n      const result = createAnalyzeActionsResult(response, this.documents);\n      return response.nextLink\n        ? { result, ...nextLinkToTopAndSkip(response.nextLink) }\n        : { result };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * returns whether the analyze actions operation is done and if so returns also\n   * statistics.\n   */\n  private async getAnalyzeActionsOperationStatus(\n    operationId: string,\n    options?: AnalyzeActionsOperationStatusOptions\n  ): Promise<AnalyzeActionsOperationStatus> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-getAnalyzeActionsOperationStatus\",\n      options || {}\n    );\n    try {\n      const response = await this.client.analyzeStatus(operationId, finalOptions);\n      switch (response.status) {\n        case \"notStarted\":\n        case \"running\":\n          break;\n        default: {\n          return {\n            done: true,\n            statistics: response.statistics,\n            operationMetdata: getMetaInfoFromResponse(response)\n          };\n        }\n      }\n      return { done: false, operationMetdata: getMetaInfoFromResponse(response) };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async beginAnalyzeActions(\n    documents: TextDocumentInput[],\n    actions: GeneratedActions,\n    options?: BeginAnalyzeInternalOptions\n  ): Promise<BeginAnalyzeResponse> {\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-beginAnalyze\",\n      options || {}\n    );\n\n    try {\n      return await this.client.analyze({\n        body: {\n          analysisInput: { documents: documents },\n          tasks: actions,\n          displayName: options?.displayName\n        },\n        ...finalOptions\n      });\n    } catch (e) {\n      const exception = handleInvalidDocumentBatch(e);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: exception.message\n      });\n      throw exception;\n    } finally {\n      span.end();\n    }\n  }\n\n  async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: AnalyzeActionsOperationState) => void;\n    } = {}\n  ): Promise<BeginAnalyzeActionsPollerOperation> {\n    const state = this.state;\n    const updatedAbortSignal = options.abortSignal;\n    if (!state.isStarted) {\n      state.isStarted = true;\n      const response = await this.beginAnalyzeActions(this.documents, this.actions, {\n        displayName: this.options.displayName,\n        tracingOptions: this.options.tracingOptions,\n        requestOptions: this.options.requestOptions,\n        abortSignal: updatedAbortSignal ? updatedAbortSignal : this.options.abortSignal\n      });\n      if (!response.operationLocation) {\n        throw new Error(\n          \"Expects a valid 'operationLocation' to retrieve analyze results but did not find any\"\n        );\n      }\n      state.operationId = getOperationId(response.operationLocation);\n    }\n\n    const operationStatus = await this.getAnalyzeActionsOperationStatus(state.operationId!, {\n      abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,\n      includeStatistics: this.options.includeStatistics,\n      tracingOptions: this.options.tracingOptions\n    });\n\n    state.createdOn = operationStatus.operationMetdata.createdOn;\n    state.expiresOn = operationStatus.operationMetdata.expiresOn;\n    state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;\n    state.status = operationStatus.operationMetdata.status;\n    state.actionsSucceededCount = operationStatus.operationMetdata.actionsSucceededCount;\n    state.actionsFailedCount = operationStatus.operationMetdata.actionsFailedCount;\n    state.actionsInProgressCount = operationStatus.operationMetdata.actionsInProgressCount;\n    state.displayName = operationStatus.operationMetdata?.displayName;\n\n    if (!state.isCompleted && operationStatus.done) {\n      const pagedIterator = this.listAnalyzeActionsResults(state.operationId!, {\n        abortSignal: this.options.abortSignal,\n        tracingOptions: this.options.tracingOptions,\n        includeStatistics: this.options.includeStatistics,\n        onResponse: this.options.onResponse,\n        serializerOptions: this.options.serializerOptions\n      });\n      // Attach stats if the service starts to return them\n      // https://github.com/Azure/azure-sdk-for-js/issues/14139\n      // state.result = Object.assign(pagedIterator, {\n      //   statistics: operationStatus.statistics\n      // });\n      state.result = pagedIterator;\n      state.isCompleted = true;\n    }\n\n    if (typeof options.fireProgress === \"function\") {\n      options.fireProgress(state);\n    }\n    return this;\n  }\n\n  async cancel(): Promise<BeginAnalyzeActionsPollerOperation> {\n    const state = this.state;\n    logger.warning(`The service does not yet support cancellation for beginAnalyze.`);\n    state.isCancelled = true;\n    return this;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PollerLike } from \"@azure/core-lro\";\nimport { PagedAnalyzeActionsResult } from \"../../analyzeActionsResult\";\nimport { JobManifestTasks as GeneratedActions } from \"../../generated/models\";\nimport { delay } from \"../../util\";\n\nimport { AnalysisPoller, AnalysisPollerOptions } from \"../poller\";\nimport {\n  BeginAnalyzeActionsPollerOperation,\n  AnalyzeActionsOperationState,\n  BeginAnalyzeActionsOptions\n} from \"./operation\";\n\n/**\n * @internal\n */\nexport interface AnalyzeActionsPollerOptions extends AnalysisPollerOptions {\n  actions: GeneratedActions;\n  readonly options: BeginAnalyzeActionsOptions;\n}\n\n/**\n * Result type of the Begin Analyze Actions Long-Running-Operation (LRO).\n */\nexport type AnalyzeActionsPollerLike = PollerLike<\n  AnalyzeActionsOperationState,\n  PagedAnalyzeActionsResult\n>;\n\n/**\n * Class that represents a poller that waits for the analyze actions results.\n * @internal\n */\nexport class BeginAnalyzeActionsPoller extends AnalysisPoller<\n  AnalyzeActionsOperationState,\n  PagedAnalyzeActionsResult\n> {\n  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters\n  constructor(pollerOptions: AnalyzeActionsPollerOptions) {\n    const {\n      client,\n      documents,\n      actions,\n      options,\n      updateIntervalInMs = 5000,\n      resumeFrom\n    } = pollerOptions;\n\n    let state: AnalyzeActionsOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n    const operation = new BeginAnalyzeActionsPollerOperation(\n      (state || {}) as any,\n      client,\n      documents,\n      actions,\n      options\n    );\n\n    super(operation);\n\n    this.updateIntervalInMs = updateIntervalInMs;\n  }\n\n  public delay(): Promise<void> {\n    return delay(this.updateIntervalInMs);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CommonClientOptions } from \"@azure/core-client\";\nimport {\n  InternalPipelineOptions,\n  bearerTokenAuthenticationPolicy\n} from \"@azure/core-rest-pipeline\";\nimport { TokenCredential, KeyCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { SDK_VERSION } from \"./constants\";\nimport { GeneratedClient } from \"./generated/generatedClient\";\nimport { logger } from \"./logger\";\nimport {\n  JobManifestTasks as GeneratedActions,\n  DetectLanguageInput,\n  GeneratedClientEntitiesRecognitionPiiOptionalParams as GeneratedRecognizePiiEntitiesOptions,\n  GeneratedClientSentimentOptionalParams as GeneratedAnalyzeSentimentOptions,\n  GeneratedClientEntitiesRecognitionGeneralOptionalParams as GeneratedRecognizeCategorizedEntitiesOptions,\n  GeneratedClientEntitiesLinkingOptionalParams as GeneratedRecognizeLinkedEntitiesOptions,\n  GeneratedClientKeyPhrasesOptionalParams as GeneratedExtractKeyPhrasesOptions,\n  GeneratedClientLanguagesOptionalParams as GeneratedDetectLanguageOptions,\n  TextDocumentInput,\n  PiiCategory\n} from \"./generated/models\";\nimport {\n  DetectLanguageResultArray,\n  makeDetectLanguageResultArray\n} from \"./detectLanguageResultArray\";\nimport {\n  RecognizeCategorizedEntitiesResultArray,\n  makeRecognizeCategorizedEntitiesResultArray\n} from \"./recognizeCategorizedEntitiesResultArray\";\nimport {\n  AnalyzeSentimentResultArray,\n  makeAnalyzeSentimentResultArray\n} from \"./analyzeSentimentResultArray\";\nimport {\n  makeExtractKeyPhrasesResultArray,\n  ExtractKeyPhrasesResultArray\n} from \"./extractKeyPhrasesResultArray\";\nimport {\n  RecognizePiiEntitiesResultArray,\n  makeRecognizePiiEntitiesResultArray\n} from \"./recognizePiiEntitiesResultArray\";\nimport {\n  RecognizeLinkedEntitiesResultArray,\n  makeRecognizeLinkedEntitiesResultArray\n} from \"./recognizeLinkedEntitiesResultArray\";\nimport { createSpan } from \"./tracing\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { textAnalyticsAzureKeyCredentialPolicy } from \"./azureKeyCredentialPolicy\";\nimport {\n  addParamsToTask,\n  compose,\n  handleInvalidDocumentBatch,\n  setCategoriesFilter,\n  setOpinionMining,\n  setStrEncodingParam,\n  setStrEncodingParamValue,\n  StringIndexType\n} from \"./util\";\nimport {\n  BeginAnalyzeHealthcarePoller,\n  AnalyzeHealthcareEntitiesPollerLike\n} from \"./lro/health/poller\";\nimport {\n  BeginAnalyzeHealthcareEntitiesOptions,\n  AnalyzeHealthcareOperationState\n} from \"./lro/health/operation\";\nimport { TextAnalyticsOperationOptions } from \"./textAnalyticsOperationOptions\";\nimport { AnalyzeActionsPollerLike, BeginAnalyzeActionsPoller } from \"./lro/analyze/poller\";\nimport {\n  AnalyzeActionsOperationMetadata,\n  BeginAnalyzeActionsOptions,\n  AnalyzeActionsOperationState\n} from \"./lro/analyze/operation\";\nimport { AnalysisPollOperationState, OperationMetadata } from \"./lro/poller\";\nimport { TextAnalyticsAction } from \"./textAnalyticsAction\";\n\nexport {\n  BeginAnalyzeActionsOptions,\n  AnalyzeActionsPollerLike,\n  AnalyzeActionsOperationState,\n  BeginAnalyzeHealthcareEntitiesOptions,\n  AnalyzeHealthcareEntitiesPollerLike,\n  AnalyzeHealthcareOperationState,\n  AnalysisPollOperationState,\n  OperationMetadata,\n  AnalyzeActionsOperationMetadata,\n  StringIndexType\n};\n\nconst DEFAULT_COGNITIVE_SCOPE = \"https://cognitiveservices.azure.com/.default\";\n\n/**\n * Client options used to configure TextAnalytics API requests.\n */\nexport interface TextAnalyticsClientOptions extends CommonClientOptions {\n  /**\n   * The default country hint to use. Defaults to \"us\".\n   */\n  defaultCountryHint?: string;\n\n  /**\n   * The default language to use. Defaults to \"en\".\n   */\n  defaultLanguage?: string;\n}\n\n/**\n * Options for the detect languages operation.\n */\nexport interface DetectLanguageOptions extends TextAnalyticsOperationOptions {}\n\n/**\n * Options for the recognize entities operation.\n */\nexport interface RecognizeCategorizedEntitiesOptions extends TextAnalyticsOperationOptions {\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n}\n\n/**\n * Options for the analyze sentiment operation.\n */\nexport interface AnalyzeSentimentOptions extends TextAnalyticsOperationOptions {\n  /**\n   * Whether to mine the opinions of a sentence and conduct more  granular\n   * analysis around the aspects of a product or service (also known as\n   * aspect-based sentiment analysis). If set to true, the returned\n   * `SentenceSentiment` objects will have property `opinions` containing\n   * the result of this analysis.\n   * More information about the feature can be found here: {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-sentiment-analysis?tabs=version-3-1#opinion-mining}\n   */\n  includeOpinionMining?: boolean;\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n}\n\n/**\n * The types of PII domains the user can choose from.\n */\nexport enum PiiEntityDomain {\n  /**\n   * @see {@link https://aka.ms/tanerpii} for more information.\n   */\n  PROTECTED_HEALTH_INFORMATION = \"PHI\"\n}\n\n/**\n * Options for the recognize PII entities operation.\n */\nexport interface RecognizePiiEntitiesOptions extends TextAnalyticsOperationOptions {\n  /**\n   * Filters entities to ones only included in the specified domain (e.g., if\n   * set to 'PHI', entities in the Protected Healthcare Information domain will\n   * only be returned). @see {@link https://aka.ms/tanerpii} for more information.\n   */\n  domainFilter?: PiiEntityDomain;\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * Filters entities to ones only included in the specified array of categories\n   */\n  categoriesFilter?: PiiCategory[];\n}\n\n/**\n * Options for the extract key phrases operation.\n */\nexport interface ExtractKeyPhrasesOptions extends TextAnalyticsOperationOptions {}\n\n/**\n * Options for the recognize linked entities operation.\n */\nexport interface RecognizeLinkedEntitiesOptions extends TextAnalyticsOperationOptions {\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n}\n\n/**\n * Options for an entities recognition action.\n */\nexport interface RecognizeCategorizedEntitiesAction extends TextAnalyticsAction {\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * If set to true, you opt-out of having your text input logged for troubleshooting. By default, Text Analytics\n   * logs your input text for 48 hours, solely to allow for troubleshooting issues. Setting this parameter to true,\n   * disables input logging and may limit our ability to remediate issues that occur.\n   */\n  disableServiceLogs?: boolean;\n}\n\n/**\n * Options for a Pii entities recognition action.\n */\nexport interface RecognizePiiEntitiesAction extends TextAnalyticsAction {\n  /**\n   * Filters entities to ones only included in the specified domain (e.g., if\n   * set to 'PHI', entities in the Protected Healthcare Information domain will\n   * only be returned). @see {@link https://aka.ms/tanerpii} for more information.\n   */\n  domainFilter?: PiiEntityDomain;\n  /**\n   * Filters entities to ones only included in the specified array of categories\n   */\n  categoriesFilter?: PiiCategory[];\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * If set to false, you opt-in to have your text input logged for troubleshooting. By default, Text Analytics\n   * will not log your input text for pii entities recognition. Setting this parameter to false,\n   * enables input logging.\n   */\n  disableServiceLogs?: boolean;\n}\n\n/**\n * Options for a key phrases recognition action.\n */\nexport interface ExtractKeyPhrasesAction extends TextAnalyticsAction {\n  /**\n   * If set to false, you opt-in to have your text input logged for troubleshooting. By default, Text Analytics\n   * will not log your input text for pii entities recognition. Setting this parameter to false,\n   * enables input logging.\n   */\n  disableServiceLogs?: boolean;\n}\n\n/**\n * Options for an entities linking action.\n */\nexport interface RecognizeLinkedEntitiesAction extends TextAnalyticsAction {\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * If set to true, you opt-out of having your text input logged for troubleshooting. By default, Text Analytics\n   * logs your input text for 48 hours, solely to allow for troubleshooting issues. Setting this parameter to true,\n   * disables input logging and may limit our ability to remediate issues that occur.\n   */\n  disableServiceLogs?: boolean;\n}\n\n/**\n * Options for an analyze sentiment action.\n */\nexport interface AnalyzeSentimentAction extends TextAnalyticsAction {\n  /**\n   * Specifies the measurement unit used to calculate the offset and length properties.\n   * Possible units are \"TextElements_v8\", \"UnicodeCodePoint\", and \"Utf16CodeUnit\".\n   * The default is the JavaScript's default which is \"Utf16CodeUnit\".\n   */\n  stringIndexType?: StringIndexType;\n  /**\n   * If set to true, you opt-out of having your text input logged for troubleshooting. By default, Text Analytics\n   * logs your input text for 48 hours, solely to allow for troubleshooting issues. Setting this parameter to true,\n   * disables input logging and may limit our ability to remediate issues that occur.\n   */\n  disableServiceLogs?: boolean;\n  /**\n   * Whether to mine the opinions of a sentence and conduct more  granular\n   * analysis around the aspects of a product or service (also known as\n   * aspect-based sentiment analysis). If set to true, the returned\n   * `SentenceSentiment` objects will have property `opinions` containing\n   * the result of this analysis.\n   * More information about the feature can be found here: {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/how-tos/text-analytics-how-to-sentiment-analysis?tabs=version-3-1#opinion-mining}\n   */\n  includeOpinionMining?: boolean;\n}\n\n/**\n * Description of collection of actions for the analyze API to perform on input documents. However, currently, the service can accept up to one action only per action type.\n */\nexport interface TextAnalyticsActions {\n  /**\n   * A collection of descriptions of entities recognition actions. However, currently, the service can accept up to one action only for `recognizeEntities`.\n   */\n  recognizeEntitiesActions?: RecognizeCategorizedEntitiesAction[];\n  /**\n   * A collection of descriptions of Pii entities recognition actions. However, currently, the service can accept up to one action only for `recognizePiiEntities`.\n   */\n  recognizePiiEntitiesActions?: RecognizePiiEntitiesAction[];\n  /**\n   * A collection of descriptions of key phrases recognition actions. However, currently, the service can accept up to one action only for `extractKeyPhrases`.\n   */\n  extractKeyPhrasesActions?: ExtractKeyPhrasesAction[];\n  /**\n   * A collection of descriptions of entities linking actions. However, currently, the service can accept up to one action only for `recognizeLinkedEntities`.\n   */\n  recognizeLinkedEntitiesActions?: RecognizeLinkedEntitiesAction[];\n  /**\n   * A collection of descriptions of sentiment analysis actions. However, currently, the service can accept up to one action only for `analyzeSentiment`.\n   */\n  analyzeSentimentActions?: AnalyzeSentimentAction[];\n}\n/**\n * Client class for interacting with Azure Text Analytics.\n */\nexport class TextAnalyticsClient {\n  /**\n   * The URL to the TextAnalytics endpoint\n   */\n  public readonly endpointUrl: string;\n\n  /**\n   * The default country hint to use. Defaults to \"us\".\n   */\n  public defaultCountryHint: string;\n\n  /**\n   * The default language to use. Defaults to \"en\".\n   */\n  public defaultLanguage: string;\n\n  /**\n   * @internal\n   * A reference to the auto-generated TextAnalytics HTTP client.\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of TextAnalyticsClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { TextAnalyticsClient, AzureKeyCredential } from \"@azure/ai-text-analytics\";\n   *\n   * const client = new TextAnalyticsClient(\n   *    \"<service endpoint>\",\n   *    new AzureKeyCredential(\"<api key>\")\n   * );\n   * ```\n   * @param endpointUrl - The URL to the TextAnalytics endpoint\n   * @param credential - Used to authenticate requests to the service.\n   * @param options - Used to configure the TextAnalytics client.\n   */\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential | KeyCredential,\n    options: TextAnalyticsClientOptions = {}\n  ) {\n    this.endpointUrl = endpointUrl;\n    const { defaultCountryHint = \"us\", defaultLanguage = \"en\", ...pipelineOptions } = options;\n    this.defaultCountryHint = defaultCountryHint;\n    this.defaultLanguage = defaultLanguage;\n\n    const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;\n    if (!pipelineOptions.userAgentOptions) {\n      pipelineOptions.userAgentOptions = {};\n    }\n    if (pipelineOptions.userAgentOptions.userAgentPrefix) {\n      pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;\n    } else {\n      pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;\n    }\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          additionalAllowedHeaderNames: [\"x-ms-correlation-request-id\", \"x-ms-request-id\"]\n        }\n      }\n    };\n\n    this.client = new GeneratedClient(this.endpointUrl, internalPipelineOptions);\n\n    const authPolicy = isTokenCredential(credential)\n      ? bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_COGNITIVE_SCOPE })\n      : textAnalyticsAzureKeyCredentialPolicy(credential);\n\n    this.client.pipeline.addPolicy(authPolicy);\n  }\n\n  /**\n   * Runs a predictive model to determine the language that the passed-in\n   * input strings are written in, and returns, for each one, the detected\n   * language as well as a score indicating the model's confidence that the\n   * inferred language is correct.  Scores close to 1 indicate high certainty in\n   * the result.  120 languages are supported.\n   * @param documents - A collection of input strings to analyze.\n   * @param countryHint - Indicates the country of origin for all of\n   *   the input strings to assist the text analytics model in predicting\n   *   the language they are written in.  If unspecified, this value will be\n   *   set to the default country hint in `TextAnalyticsClientOptions`.\n   *   If set to an empty string, or the string \"none\", the service will apply a\n   *   model where the country is explicitly unset.\n   *   The same country hint is applied to all strings in the input collection.\n   * @param options - Optional parameters for the operation.\n   */\n  public async detectLanguage(\n    documents: string[],\n    countryHint?: string,\n    options?: DetectLanguageOptions\n  ): Promise<DetectLanguageResultArray>;\n  /**\n   * Runs a predictive model to determine the language that the passed-in\n   * input document are written in, and returns, for each one, the detected\n   * language as well as a score indicating the model's confidence that the\n   * inferred language is correct.  Scores close to 1 indicate high certainty in\n   * the result.  120 languages are supported.\n   * @param documents - A collection of input documents to analyze.\n   * @param options - Optional parameters for the operation.\n   */\n  public async detectLanguage(\n    documents: DetectLanguageInput[],\n    options?: DetectLanguageOptions\n  ): Promise<DetectLanguageResultArray>;\n  public async detectLanguage(\n    documents: string[] | DetectLanguageInput[],\n    countryHintOrOptions?: string | DetectLanguageOptions,\n    options?: DetectLanguageOptions\n  ): Promise<DetectLanguageResultArray> {\n    let realOptions: DetectLanguageOptions;\n    let realInputs: DetectLanguageInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const countryHint = (countryHintOrOptions as string) || this.defaultCountryHint;\n      realInputs = convertToDetectLanguageInput(documents, countryHint);\n      realOptions = options || {};\n    } else {\n      // Replace \"none\" hints with \"\"\n      realInputs = documents.map((input) => ({\n        ...input,\n        countryHint: input.countryHint === \"none\" ? \"\" : input.countryHint\n      }));\n      realOptions = (countryHintOrOptions as DetectLanguageOptions) || {};\n    }\n\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-detectLanguages\",\n      makeGeneratedDetectLanguageOptions(realOptions)\n    );\n\n    try {\n      const result = await this.client.languages(\n        {\n          documents: realInputs\n        },\n        finalOptions\n      );\n\n      return makeDetectLanguageResultArray(realInputs, result);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Runs a predictive model to identify a collection of named entities\n   * in the passed-in input strings, and categorize those entities into types\n   * such as person, location, or organization.  For more information on \n   * available categories, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/Text-Analytics/named-entity-types}.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input strings to analyze.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.  \n        If set to an empty string, the service will apply a model\n        where the language is explicitly set to \"None\".\n   * @param options - Optional parameters for the operation.\n   */\n  public async recognizeEntities(\n    documents: string[],\n    language?: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: RecognizeCategorizedEntitiesOptions\n  ): Promise<RecognizeCategorizedEntitiesResultArray>;\n  /**\n   * Runs a predictive model to identify a collection of named entities\n   * in the passed-in input documents, and categorize those entities into types\n   * such as person, location, or organization.  For more information on\n   * available categories, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/Text-Analytics/named-entity-types}.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input documents to analyze.\n   * @param options - Optional parameters for the operation.\n   */\n  public async recognizeEntities(\n    documents: TextDocumentInput[],\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: RecognizeCategorizedEntitiesOptions\n  ): Promise<RecognizeCategorizedEntitiesResultArray>;\n  public async recognizeEntities(\n    documents: string[] | TextDocumentInput[],\n    languageOrOptions?: string | RecognizeCategorizedEntitiesOptions,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: RecognizeCategorizedEntitiesOptions\n  ): Promise<RecognizeCategorizedEntitiesResultArray> {\n    let realOptions: RecognizeCategorizedEntitiesOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, language);\n      realOptions = options || {};\n    } else {\n      realInputs = documents;\n      realOptions = (languageOrOptions as RecognizeCategorizedEntitiesOptions) || {};\n    }\n\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-recognizeEntities\",\n      makeGeneratedRecognizeCategorizedEntitiesOptions(realOptions)\n    );\n\n    try {\n      const result = await this.client.entitiesRecognitionGeneral(\n        {\n          documents: realInputs\n        },\n        finalOptions\n      );\n\n      return makeRecognizeCategorizedEntitiesResultArray(realInputs, result);\n    } catch (e) {\n      /**\n       * This special logic handles REST exception with code\n       * InvalidDocumentBatch and is needed to maintain backward compatability\n       * with sdk v5.0.0 and earlier. In general, REST exceptions are thrown as\n       * is and include both outer and inner exception codes. However, the\n       * earlier versions were throwing an exception that included the inner\n       * code only.\n       */\n      const backwardCompatibleException = handleInvalidDocumentBatch(e);\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: backwardCompatibleException.message\n      });\n      throw backwardCompatibleException;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Runs a predictive model to identify the positive, negative, neutral, or mixed\n   * sentiment contained in the input strings, as well as scores indicating\n   * the model's confidence in each of the predicted sentiments. Optionally it\n   * can also identify targets in the text and assessments about it through\n   * opinion mining. For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input strings to analyze.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.  \n        If set to an empty string, the service will apply a model\n        where the lanuage is explicitly set to \"None\".\n   * @param options - Optional parameters that includes enabling opinion mining.\n   */\n  public async analyzeSentiment(\n    documents: string[],\n    language?: string,\n    options?: AnalyzeSentimentOptions\n  ): Promise<AnalyzeSentimentResultArray>;\n  /**\n   * Runs a predictive model to identify the positive, negative or neutral, or mixed\n   * sentiment contained in the input documents, as well as scores indicating\n   * the model's confidence in each of the predicted sentiments.Optionally it\n   * can also identify targets in the text and assessments about it through\n   * opinion mining. For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input documents to analyze.\n   * @param options - Optional parameters that includes enabling opinion mining.\n   */\n  public async analyzeSentiment(\n    documents: TextDocumentInput[],\n    options?: AnalyzeSentimentOptions\n  ): Promise<AnalyzeSentimentResultArray>;\n  public async analyzeSentiment(\n    documents: string[] | TextDocumentInput[],\n    languageOrOptions?: string | AnalyzeSentimentOptions,\n    options?: AnalyzeSentimentOptions\n  ): Promise<AnalyzeSentimentResultArray> {\n    let realOptions: AnalyzeSentimentOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, language);\n      realOptions = options || {};\n    } else {\n      realInputs = documents;\n      realOptions = (languageOrOptions as AnalyzeSentimentOptions) || {};\n    }\n\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-analyzeSentiment\",\n      makeGeneratedAnalyzeSentimentOptions(realOptions)\n    );\n\n    try {\n      const result = await this.client.sentiment(\n        {\n          documents: realInputs\n        },\n        finalOptions\n      );\n\n      return makeAnalyzeSentimentResultArray(realInputs, result);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Runs a model to identify a collection of significant phrases\n   * found in the passed-in input strings.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input strings to analyze.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.  \n        If set to an empty string, the service will apply a model\n        where the language is explicitly set to \"None\".\n   * @param options - Options for the operation.\n   */\n  public async extractKeyPhrases(\n    documents: string[],\n    language?: string,\n    options?: ExtractKeyPhrasesOptions\n  ): Promise<ExtractKeyPhrasesResultArray>;\n  /**\n   * Runs a model to identify a collection of significant phrases\n   * found in the passed-in input documents.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input documents to analyze.\n   * @param options - Options for the operation.\n   */\n  public async extractKeyPhrases(\n    documents: TextDocumentInput[],\n    options?: ExtractKeyPhrasesOptions\n  ): Promise<ExtractKeyPhrasesResultArray>;\n  public async extractKeyPhrases(\n    documents: string[] | TextDocumentInput[],\n    languageOrOptions?: string | ExtractKeyPhrasesOptions,\n    options?: ExtractKeyPhrasesOptions\n  ): Promise<ExtractKeyPhrasesResultArray> {\n    let realOptions: ExtractKeyPhrasesOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, language);\n      realOptions = options || {};\n    } else {\n      realInputs = documents;\n      realOptions = (languageOrOptions as ExtractKeyPhrasesOptions) || {};\n    }\n\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-extractKeyPhrases\",\n      makeGeneratedExtractKeyPhrasesOptions(realOptions)\n    );\n\n    try {\n      const result = await this.client.keyPhrases(\n        {\n          documents: realInputs\n        },\n        finalOptions\n      );\n\n      return makeExtractKeyPhrasesResultArray(realInputs, result);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Runs a predictive model to identify a collection of entities containing\n   * personally identifiable information found in the passed-in input strings,\n   * and categorize those entities into types such as US social security\n   * number, drivers license number, or credit card number.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/language-support}.\n   * @param inputs - The input strings to analyze.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.  \n        If set to an empty string, the service will apply a model\n        where the language is explicitly set to \"None\".\n   * @param options - Options for the operation.\n   */\n  public async recognizePiiEntities(\n    inputs: string[],\n    language?: string,\n    options?: RecognizePiiEntitiesOptions\n  ): Promise<RecognizePiiEntitiesResultArray>;\n  /**\n   * Runs a predictive model to identify a collection of entities containing\n   * personally identifiable information found in the passed-in input documents,\n   * and categorize those entities into types such as US social security\n   * number, drivers license number, or credit card number.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/en-us/azure/cognitive-services/text-analytics/language-support}.\n   * @param inputs - The input documents to analyze.\n   * @param options - Optional parameters for the operation.\n   */\n  public async recognizePiiEntities(\n    inputs: TextDocumentInput[],\n    options?: RecognizePiiEntitiesOptions\n  ): Promise<RecognizePiiEntitiesResultArray>;\n  public async recognizePiiEntities(\n    inputs: string[] | TextDocumentInput[],\n    languageOrOptions?: string | RecognizePiiEntitiesOptions,\n    options?: RecognizePiiEntitiesOptions\n  ): Promise<RecognizePiiEntitiesResultArray> {\n    let realOptions: RecognizePiiEntitiesOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (isStringArray(inputs)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(inputs, language);\n      realOptions = options || {};\n    } else {\n      realInputs = inputs;\n      realOptions = (languageOrOptions as RecognizePiiEntitiesOptions) || {};\n    }\n\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-recognizePiiEntities\",\n      makeGeneratedRecognizePiiEntitiesOptions(realOptions)\n    );\n\n    try {\n      const result = await this.client.entitiesRecognitionPii(\n        {\n          documents: realInputs\n        },\n        finalOptions\n      );\n\n      return makeRecognizePiiEntitiesResultArray(realInputs, result);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Runs a predictive model to identify a collection of entities\n   * found in the passed-in input strings, and include information linking the\n   * entities to their corresponding entries in a well-known knowledge base.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input strings to analyze.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.  \n        If set to an empty string, the service will apply a model\n        where the language is explicitly set to \"None\".\n   * @param options - Options for the operation.\n   */\n  public async recognizeLinkedEntities(\n    documents: string[],\n    language?: string,\n    options?: RecognizeLinkedEntitiesOptions\n  ): Promise<RecognizeLinkedEntitiesResultArray>;\n  /**\n   * Runs a predictive model to identify a collection of entities\n   * found in the passed-in input documents, and include information linking the\n   * entities to their corresponding entries in a well-known knowledge base.\n   * For a list of languages supported by this operation, @see\n   * {@link https://docs.microsoft.com/azure/cognitive-services/text-analytics/language-support}.\n   * @param documents - The input documents to analyze.\n   * @param options - Options for the operation.\n   */\n  public async recognizeLinkedEntities(\n    documents: TextDocumentInput[],\n    options?: RecognizeLinkedEntitiesOptions\n  ): Promise<RecognizeLinkedEntitiesResultArray>;\n  public async recognizeLinkedEntities(\n    documents: string[] | TextDocumentInput[],\n    languageOrOptions?: string | RecognizeLinkedEntitiesOptions,\n    options?: RecognizeLinkedEntitiesOptions\n  ): Promise<RecognizeLinkedEntitiesResultArray> {\n    let realOptions: RecognizeLinkedEntitiesOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, language);\n      realOptions = options || {};\n    } else {\n      realInputs = documents;\n      realOptions = (languageOrOptions as RecognizeLinkedEntitiesOptions) || {};\n    }\n\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"TextAnalyticsClient-recognizeLinkedEntities\",\n      makeGeneratedRecognizeLinkingEntitiesOptions(realOptions)\n    );\n\n    try {\n      const result = await this.client.entitiesLinking(\n        {\n          documents: realInputs\n        },\n        finalOptions\n      );\n\n      return makeRecognizeLinkedEntitiesResultArray(realInputs, result);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Start a healthcare analysis operation to recognize healthcare related entities (drugs, conditions,\n   * symptoms, etc) and their relations.\n   * @param documents - Collection of documents to analyze.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.\n        If set to an empty string, the service will apply a model\n        where the language is explicitly set to \"None\".\n   * @param options - Options for the operation.\n   */\n  async beginAnalyzeHealthcareEntities(\n    documents: string[],\n    language?: string,\n    options?: BeginAnalyzeHealthcareEntitiesOptions\n  ): Promise<AnalyzeHealthcareEntitiesPollerLike>;\n  /**\n   * Start a healthcare analysis operation to recognize healthcare related entities (drugs, conditions,\n   * symptoms, etc) and their relations.\n   * @param documents - Collection of documents to analyze.\n   * @param options - Options for the operation.\n   */\n  async beginAnalyzeHealthcareEntities(\n    documents: TextDocumentInput[],\n    options?: BeginAnalyzeHealthcareEntitiesOptions\n  ): Promise<AnalyzeHealthcareEntitiesPollerLike>;\n\n  async beginAnalyzeHealthcareEntities(\n    documents: string[] | TextDocumentInput[],\n    languageOrOptions?: string | BeginAnalyzeHealthcareEntitiesOptions,\n    options?: BeginAnalyzeHealthcareEntitiesOptions\n  ): Promise<AnalyzeHealthcareEntitiesPollerLike> {\n    let realOptions: BeginAnalyzeHealthcareEntitiesOptions;\n    let realInputs: TextDocumentInput[];\n    if (isStringArray(documents)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, language);\n      realOptions = options || {};\n    } else {\n      realInputs = documents;\n      realOptions = (languageOrOptions as BeginAnalyzeHealthcareEntitiesOptions) || {};\n    }\n\n    const { updateIntervalInMs, resumeFrom, ...restOptions } = realOptions;\n    const poller = new BeginAnalyzeHealthcarePoller({\n      client: this.client,\n      documents: realInputs,\n      options: restOptions,\n      updateIntervalInMs: updateIntervalInMs,\n      resumeFrom: resumeFrom\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Submit a collection of text documents for analysis. Specify one or more unique actions to be executed.\n   * @param documents - Collection of documents to analyze\n   * @param actions - TextAnalyticsActions to execute.\n   * @param language - The language that all the input strings are\n        written in. If unspecified, this value will be set to the default\n        language in `TextAnalyticsClientOptions`.\n        If set to an empty string, the service will apply a model\n        where the language is explicitly set to \"None\".\n   * @param options - Options for the operation.\n   */\n  public async beginAnalyzeActions(\n    documents: string[],\n    actions: TextAnalyticsActions,\n    language?: string,\n    options?: BeginAnalyzeActionsOptions\n  ): Promise<AnalyzeActionsPollerLike>;\n  /**\n   * Submit a collection of text documents for analysis. Specify one or more unique actions to be executed.\n   * @param documents - Collection of documents to analyze\n   * @param actions - TextAnalyticsActions to execute.\n   * @param options - Options for the operation.\n   */\n  public async beginAnalyzeActions(\n    documents: TextDocumentInput[],\n    actions: TextAnalyticsActions,\n    options?: BeginAnalyzeActionsOptions\n  ): Promise<AnalyzeActionsPollerLike>;\n  public async beginAnalyzeActions(\n    documents: string[] | TextDocumentInput[],\n    actions: TextAnalyticsActions,\n    languageOrOptions?: string | BeginAnalyzeActionsOptions,\n    options?: BeginAnalyzeActionsOptions\n  ): Promise<AnalyzeActionsPollerLike> {\n    let realOptions: BeginAnalyzeActionsOptions;\n    let realInputs: TextDocumentInput[];\n\n    if (!Array.isArray(documents) || documents.length === 0) {\n      throw new Error(\"'documents' must be a non-empty array\");\n    }\n\n    if (isStringArray(documents)) {\n      const language = (languageOrOptions as string) || this.defaultLanguage;\n      realInputs = convertToTextDocumentInput(documents, language);\n      realOptions = options || {};\n    } else {\n      realInputs = documents;\n      realOptions = (languageOrOptions as BeginAnalyzeActionsOptions) || {};\n    }\n    validateActions(actions);\n    const compiledActions = compileAnalyzeInput(actions);\n    const { updateIntervalInMs, resumeFrom, ...restOptions } = realOptions;\n    const poller = new BeginAnalyzeActionsPoller({\n      client: this.client,\n      documents: realInputs,\n      actions: compiledActions,\n      options: restOptions,\n      resumeFrom: resumeFrom,\n      updateIntervalInMs: updateIntervalInMs\n    });\n\n    await poller.poll();\n    return poller;\n  }\n}\n\nfunction validateActions(actions: TextAnalyticsActions): void {\n  function validateActionType(actionList: unknown[] | undefined, actionType: string): void {\n    if ((actionList?.length ?? 0) > 1) {\n      throw new Error(\n        `beginAnalyzeActions: Currently, the service can accept up to one action only for ${actionType} actions.`\n      );\n    }\n  }\n  validateActionType(actions.analyzeSentimentActions, `analyzeSentiment`);\n  validateActionType(actions.extractKeyPhrasesActions, `extractKeyPhrases`);\n  validateActionType(actions.recognizeEntitiesActions, `recognizeEntities`);\n  validateActionType(actions.recognizeLinkedEntitiesActions, `recognizeLinkedEntities`);\n  validateActionType(actions.recognizePiiEntitiesActions, `recognizePiiEntities`);\n}\n\n/**\n * @internal\n */\nfunction compileAnalyzeInput(actions: TextAnalyticsActions): GeneratedActions {\n  return {\n    entityRecognitionPiiTasks: actions.recognizePiiEntitiesActions?.map(\n      compose(setStrEncodingParam, compose(setCategoriesFilter, addParamsToTask))\n    ),\n    entityRecognitionTasks: actions.recognizeEntitiesActions?.map(\n      compose(setStrEncodingParam, addParamsToTask)\n    ),\n    keyPhraseExtractionTasks: actions.extractKeyPhrasesActions?.map(addParamsToTask),\n    entityLinkingTasks: actions.recognizeLinkedEntitiesActions?.map(\n      compose(setStrEncodingParam, addParamsToTask)\n    ),\n    sentimentAnalysisTasks: actions.analyzeSentimentActions?.map(\n      compose(setStrEncodingParam, compose(setOpinionMining, addParamsToTask))\n    )\n  };\n}\n\nfunction isStringArray(documents: any[]): documents is string[] {\n  return typeof documents[0] === \"string\";\n}\n\n/**\n * @internal\n */\nfunction convertToDetectLanguageInput(\n  inputs: string[],\n  countryHint: string\n): DetectLanguageInput[] {\n  if (countryHint === \"none\") {\n    countryHint = \"\";\n  }\n  return inputs.map(\n    (text: string, index): DetectLanguageInput => {\n      return {\n        id: String(index),\n        countryHint,\n        text\n      };\n    }\n  );\n}\n\n/**\n * @internal\n */\nfunction convertToTextDocumentInput(inputs: string[], language: string): TextDocumentInput[] {\n  return inputs.map(\n    (text: string, index): TextDocumentInput => {\n      return {\n        id: String(index),\n        language,\n        text\n      };\n    }\n  );\n}\n\n/**\n * Creates the options the service expects for the analyze sentiment API from the user friendly ones.\n * @param params - the user friendly parameters\n * @internal\n */\nfunction makeGeneratedAnalyzeSentimentOptions(\n  params: AnalyzeSentimentOptions\n): GeneratedAnalyzeSentimentOptions {\n  return {\n    abortSignal: params.abortSignal,\n    opinionMining: params.includeOpinionMining,\n    includeStatistics: params.includeStatistics,\n    modelVersion: params.modelVersion,\n    requestOptions: params.requestOptions,\n    stringIndexType: setStrEncodingParamValue(params.stringIndexType),\n    tracingOptions: params.tracingOptions,\n    onResponse: params.onResponse,\n    serializerOptions: params.serializerOptions,\n    loggingOptOut: params.disableServiceLogs\n  };\n}\n\n/**\n * Creates the options the service expects for the recognize pii entities API from the user friendly ones.\n * @param params - the user friendly parameters\n * @internal\n */\nfunction makeGeneratedRecognizePiiEntitiesOptions(\n  params: RecognizePiiEntitiesOptions\n): GeneratedRecognizePiiEntitiesOptions {\n  return {\n    abortSignal: params.abortSignal,\n    domain: params.domainFilter,\n    includeStatistics: params.includeStatistics,\n    modelVersion: params.modelVersion,\n    requestOptions: params.requestOptions,\n    stringIndexType: setStrEncodingParamValue(params.stringIndexType),\n    tracingOptions: params.tracingOptions,\n    piiCategories: params.categoriesFilter,\n    onResponse: params.onResponse,\n    serializerOptions: params.serializerOptions,\n    loggingOptOut: params.disableServiceLogs\n  };\n}\n\n/**\n * Creates the options the service expects for the recognize entities API from the user friendly ones.\n * @param params - the user friendly parameters\n * @internal\n */\nfunction makeGeneratedRecognizeCategorizedEntitiesOptions(\n  params: RecognizeCategorizedEntitiesOptions\n): GeneratedRecognizeCategorizedEntitiesOptions {\n  return {\n    abortSignal: params.abortSignal,\n    includeStatistics: params.includeStatistics,\n    modelVersion: params.modelVersion,\n    requestOptions: params.requestOptions,\n    stringIndexType: setStrEncodingParamValue(params.stringIndexType),\n    tracingOptions: params.tracingOptions,\n    onResponse: params.onResponse,\n    serializerOptions: params.serializerOptions,\n    loggingOptOut: params.disableServiceLogs\n  };\n}\n\n/**\n * Creates the options the service expects for the detect language API from the user friendly ones.\n * @param params - the user friendly parameters\n * @internal\n */\nfunction makeGeneratedDetectLanguageOptions(\n  params: DetectLanguageOptions\n): GeneratedDetectLanguageOptions {\n  return {\n    abortSignal: params.abortSignal,\n    includeStatistics: params.includeStatistics,\n    modelVersion: params.modelVersion,\n    requestOptions: params.requestOptions,\n    tracingOptions: params.tracingOptions,\n    onResponse: params.onResponse,\n    serializerOptions: params.serializerOptions,\n    loggingOptOut: params.disableServiceLogs\n  };\n}\n\n/**\n * Creates the options the service expects for the extract key phrases API from the user friendly ones.\n * @param params - the user friendly parameters\n * @internal\n */\nfunction makeGeneratedExtractKeyPhrasesOptions(\n  params: ExtractKeyPhrasesOptions\n): GeneratedExtractKeyPhrasesOptions {\n  return {\n    abortSignal: params.abortSignal,\n    includeStatistics: params.includeStatistics,\n    modelVersion: params.modelVersion,\n    requestOptions: params.requestOptions,\n    tracingOptions: params.tracingOptions,\n    onResponse: params.onResponse,\n    serializerOptions: params.serializerOptions,\n    loggingOptOut: params.disableServiceLogs\n  };\n}\n\n/**\n * Creates the options the service expects for the recognize linked entities API from the user friendly ones.\n * @param params - the user friendly parameters\n * @internal\n */\nfunction makeGeneratedRecognizeLinkingEntitiesOptions(\n  params: RecognizeLinkedEntitiesOptions\n): GeneratedRecognizeLinkedEntitiesOptions {\n  return {\n    abortSignal: params.abortSignal,\n    includeStatistics: params.includeStatistics,\n    modelVersion: params.modelVersion,\n    requestOptions: params.requestOptions,\n    tracingOptions: params.tracingOptions,\n    onResponse: params.onResponse,\n    serializerOptions: params.serializerOptions,\n    loggingOptOut: params.disableServiceLogs,\n    stringIndexType: setStrEncodingParamValue(params.stringIndexType)\n  };\n}\n"],
  "mappings": "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",
  "names": ["serializer", "result", "contentType", "body", "input", "url", "endpoint", "url", "contentType", "endpoint", "endpoint", "jobId", "input", "logger", "logger", "stringIndexType", "url", "top", "skip", "logger", "input", "input", "input", "input", "input", "input", "input", "cache", "isCompatible", "diag", "DiagComponentLogger", "logger", "DiagLogLevel", "logger", "DiagAPI", "logger", "__spreadArray", "__read", "self", "BaggageImpl", "__read", "BaseContext", "self", "context", "DiagConsoleLogger", "NoopMeter", "NoopMetric", "NoopCounterMetric", "NoopUpDownCounterMetric", "NoopHistogramMetric", "NoopObservableMetric", "NoopObservableCounterMetric", "NoopObservableGaugeMetric", "NoopObservableUpDownCounterMetric", "ValueType", "NoopContextManager", "__spreadArray", "__read", "API_NAME", "ContextAPI", "context", "__spreadArray", "__read", "TraceFlags", "NonRecordingSpan", "context", "NoopTracer", "context", "ProxyTracer", "context", "NoopTracerProvider", "ProxyTracerProvider", "SamplingDecision", "SpanKind", "SpanStatusCode", "TraceStateImpl", "diag", "NoopMeterProvider", "API_NAME", "MetricsAPI", "NoopTextMapPropagator", "context", "context", "API_NAME", "PropagationAPI", "context", "API_NAME", "TraceAPI", "SpanKind", "setSpan", "context", "context", "SpanStatusCode", "SpanKind", "setSpan", "context", "logger", "SpanStatusCode", "getMetaInfoFromResponse", "SpanStatusCode", "logger", "PiiEntityDomain", "logger", "input", "SpanStatusCode"]
}
